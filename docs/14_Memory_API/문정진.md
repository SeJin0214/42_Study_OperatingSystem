# 메모리 관리 API
>unix 메모리 관리 인터페이스 논의!
## 17.1 메모리 공간의 종류
c 프로그램 실행 시, 두 가지 유형의 메모리 공간에 할당.
스택(stach) 메모리
* 할당과 반환은 프로그래머 위해 암무적으로 이루어짐. 자동 메모리로도 불림.
* 스텍 메모리 선언은 쉬움, func 함수 안에 x 변수 선언하면, 컴파일러가 해당 함수를 호출 할 때, 스택 공간이 확보됨.
* 함수 리턴하면서 메모리를 반환, 함수 리턴 값을 유지하려면 스택에 저장하는 것은 좋지 않음.
힙(heap) 메모리
* 오래동안 값이 유지되어야하는 변수. 할당과 반환이 명시적으로 처리.
* 주의 사항 : 한 행에 스택과 힙 할당 모두 발생
* 컴파일러가 포인터 변수의 선언을 만나면 정수 포인터를 위한 공간을 할당.
* malloc 호출하여 정수를 위한 공간을 heap 으로부터 요구
* malloc 은 그 정수의 주소를 반환.
* 반환된 주소는 스택에 저장되어 프로그램에 의해 사용.
## 17.2 malloc() 함수
* 힙 요청 할 공간 크기 넘겨주고, 성공했을 때, 포인터로 반환, 실패시 NULL 반환.
* malloc은 stdlib.h 헤더를 가져오면 사용할 수 있음.
* 컴파일러는 전달된 인자의 개수가 맞는지 올바른 데이터 타입인지 확인함.
## 17.3 free() 함수
* 메모리 할당 해제!
## 17.4 흔한 오류
c 외의 다른 언어들은 자동 메모리 관리를 지원함 (가비지 콜렉터 / 쓰레기 수집기가 있음)
* 메모리 할당 잊어버리기
    세그멘테이션 폴트 - 예를들어 메모리 할당을 하지 않고, 값을 집어넣으려 했을 때,
* 메모리 부족하게 할당 받기
    들어가려는 데이터가 10개인데 8개로 메모리 할당 했을 때,
* 할당 받은 메모리 초기화 하지 않기
    호출을 제대로 했지만, 초기화 하지 않은 경우, 쓰레기 값들이 들어갈 수 있음.
* 메모리 해제하지 않기
    메모리 누수 - leak, 할당한 메모리를 free를 통해 해제 않을 경우 발생.
* 메모리 사용하기 전에 메모리 해제
    데이터를 사용하기 전에 free시키고, 해당 값을 찾으려할 때, .뎅글링 포인터 발생.
* 반복적으로 메모리 해제하기
    이중 해제 문제
* free 잘못 호출하기
    유요하지않는 해제
## 17.5 운영체제의 지원
malloc과 free는 시스템 콜이 아니라 라이브러리 함수다!!!
라이브러리가 프로세스 가상 주소 공간을 관리하지만 라이브러리 자체는 시스템에게 더 많은 메모리를 요구하고 반환하는 시스템 콜을 기반으로 구축.
brk 시스템 콜
* 프로그램의 break 위치를 변경하는데 사용
* break는 힙의 마지막 위치를 나타냄
* brk는 새로운 break 주소를 나타내는 한 개의 인자를 받음.
* break가 새로운 break와 크기를 비교하여 힙 크기 증가 감소.
* sbrk는 증가랑만 받아드림.
* brk sbrk는 직접 호출하면 안됨!!
mmap() 함수
* 운영체제로부터 메모리 얻기 가능.
* mmap는 프로그램에 anonymouns 메모리 영역 만듬
* 해당 영역은 특정 파일과 연결되지 않고 스왑 공간에 연결된 영역.
## 17.6 기타 함수들
* calloc() = 메모리 할당 영역을 0으로 가득 채움
* realloc() = 이미 할당된 공간에 추가의 공간이 필요로 할 때
## 17.7 요약
기본적인 api만 다뤘다! 다른 책과 논문을 참고해라!