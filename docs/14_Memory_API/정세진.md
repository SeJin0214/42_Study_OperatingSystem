<aside>
💡 어떻게 메모리를 할당하고 관리해야 하는가?

UNIX, C 프로그램에서 어떤 인터페이스가 사용되는가?

</aside>

# 메모리 관리 API

## 스택

컴파일 때 함수 프레임이 결정된다. 

```nasm

void func() {
		int x;
		...
}

func:
		push ebp
		mov ebp, esp
		sub esp, 4
		...
		add esp, 4
		pop ebp
		ret
		

```

~~컴파일러가 프로그래머 대신 메모리를 반환한다~~. (이건 컴파일러가 아니라, 컴파일러가 만들어낸 명령어가 수행하고, 런타임 시스템이 도와주는 것으로 알고 있다.)

```c
void func() {
	// 스택에 8바이트 (윈도우 4바이트)
	int *x = (int *) malloc(sizeof(int));
	// 힙에 할당된 주소를 x에 대입
	. . .
}
```

## malloc()

sizeof() 연산자 사용해서 할당하기~~~

sizeof() 는 컴파일 때 결정되니 연산자로 간주 되는 게 맞다~

## free()

이제 사용하지 않는 힙 메모리는 free()~~~

## 흔한 오류

1. 메모리 할당 까먹기
    
    ```c
    char *src =“hello ”;
    char *dst; 
    strcpy(dst, src); // 크래시!!
    ```
    
2. 메모리 부족하게 할당하기
    
    ```c
    char *src =“hello ”
    char *dst = (char *) malloc(strlen(src));  
    strcpy(dst, src); // 마지막 문자가 짤림
    ```
    

세그멘테이션 폴트란 용어도 나중에 설명해줌

1. 할당받은 메모리 초기화하지 않기
    1. 초기화되지 않은 읽기(uninitialized read) == 쓰레기 값 읽기
2. 메모리 해제하지 않기
    1. 누수가 점차 커져 운영체제가 메모리를 더이상 줄 수 없게 될 경우, 프로그램을 재시작 해야함 
    2. GC가 있는 언어도 누수가 생김, 참조를 아직도 하고 있는 경우 
    3. 습관을 잘 들여라
3. 메모리 사용이 끝나기 전에 메모리 해제하기
    1. 해제된 메모리는 참조할 수 없음, 댕글링 포인터
4. double free
5. 이상한 곳 free

메모리 관련 검토 도구

- purify
- valgrind

- 여담
    
    > 시스템이 실제 두 단계로 메모리를 관리
    > 
    > 
    > 메모리 관리의 첫 번째 단계는 운영체제에 의해 수행된다. 프로세스가 실행할 때 메모리를 프로세스에게 건네 주고 프로세스가 종료하거나 다른 이유로 죽을 때 메모리를 되돌려 받는다.
    > 
    > 두 번째 단계는 각 프로세스 내에서, 예를 들면, malloc()과 free()를 호출할 때 힙 내에서 수행된다. free()를 호출하지 못했더라도 그래서 메모리가 누수되더라도 프로세스가 종료할 때, 운영체제는 프로세스의 모든 페이지를 회수
    > 

## 운영체제의 지원

malloc과 free는 system call이 아닌 일반 라이브러리 함수!

malloc

- 프로세스 가상 주소 공간 안의 공간을 관리
- 시스템에게 더 많은 메모리를 요구하고 반환하는 시스템 콜을 기반으로 구축한다.
- **brk라는 시스템 콜**, (sbrk 도 있다)
    - **프로그램의 break 주소를 변경하는데 사용**
        - **break는 힙의 마지막 주소**
    - 직접 호출하지 말 것!

mmap

- 익명의 메모리 영역을 만든다.
- 스왑 공간에 연결된 영역
- 힙처럼 관리되고 취급된다.

가상 메모리에서 더 본다.

## 좀 더 알아볼 것

스택은 고정된 바이트로 받는다. 1MB

함수 call을 하면 프레임이 잡히고, 영역에서 벗어나는 곳을 접근하면 운영체제가 잡아준다.