# 막긴: 메모리 관리 API
unix의 메모리 관리 인터페이스를 논의한다.
</br>
</br>

## 메모리 공간의 종류
C프로그램이 실행되면 2가지 유형의 메모리 공간이 할당된다. 
1. 스텍
   - 할당과 반환은 컴파일러에 의해 암묵적으로 이뤄짐.
     - 그러므로 자동(automatic)메모리라고도 불림.
   - 보통 함수 안에서 선언하는 일반적인 변수를 생각하면 된다.
	> void func()  
	> {  
	>	int x;  
		. . .  
	> }
   - 컴파일러는 func()가 호출될 때 스텍에 공간을 확보한다.
   - 함수 리턴후에는 유지되지 않는다.

2. 힙
   - 오랫동안 값이 유지되어야 하는 변수는 힙 메모리가 필요하다.
   - 프로그래머가 직접 모든 할당과 반환을 해야 한다.
   - 그러지 않을시 많은 버그가 발생한다. 

## 2. malloc()함수
- 성공했ㅇ르 경우 새로 할당된 공간의 포인터를 반환, 실패시 NULL 반환
- stdlib.h 필요
- (등등 다 아는 것들)

## 3. free()함수
- 할당된 메모리를 해제

## 흔한 오류
malloc과 free를 사용하는 데 흔히 발생하는 오류중 일부를 소개한다.

많은 새로운 언어들이 자동메모리 관리(automatic memory management)를 지원한다. 할당을 위해서는 malloc과 유사한 new 등의 루틴을 호출하는 반면, 공간을 해제하기 위해선 아무것도 호출하지 않는다. 쓰레기 수집기(garbage collector)가 실행되어 알아서 해제한다.

### 메모리 할당 잊어버리기
많은 루틴은 자신이 호출되기 전에, 필요한 메모리가 미리 할당되었다고 가정한다. 
>...   
>char *dst;  
>strcpy(dst, src);  
>...   

위 코드는 segmentation fault가 발생할 확률이 높다. 

대안으로는 strdup()를 사용하면 된다.


### 메모리 부족하게 할당받기
메모리를 부족하게 할당받는 오류는 버퍼 오버플로우(buffer over-flow)라 불린다.  
목적지 버퍼공간을 약간 부족하게 할당받는 것이다.
- malloc이 때때로 제대로 동작하는 것처럼 보이는 경우가 종종 있다.
- 가령, 문자열 복사가 실행될 때, 할당된 공간의 마지막을 지나쳐 한 바이트만큼 더 공간을 사용한다. 
- 더이상 사용되지 않는 변수 영역이라 덮어써도 아무 피해가 발생하지 않으나, 때떄로 이는 매우 유해하거나 보안취약점의 원인이 될 수 있다.  
- 프로그램이 고장을 일으키고 크래시될 수도 있다.


### 할당받은 메모리 초기화하지 않기
malloc을 제대로 호출했지만, 새로 할당받은 데이터 타입에 특정 값을 넣는 것을 잊는 경우이다.  
초기화되지 않은 읽기(uninitialized read)-> 즉, 힙으로부터 알 수 없는 값을 읽는다.  
재수없으면 임의의 값이나 해로운 값이 읽힐 것이다.
</br>
</br>

### 메모리 해제하지 않기
메모리 누수(memory leak)은 장시간 실행되는 응용프로그램 또는 운영체제 자체와 같은 시스템 프로그램에서는 큰 문제이다.
 - 메모리가 누수되면 결국 메모리가 부족하게 되어 시스템을 재시작할 수 밖에 없다. 
 - 메모리 청크의 사용이 끝나면 반드시 해제해야 한다. 
 - 갈비지 콜랙터가 있어도, 메모리 청크의 참조가 존재하면 어떤 콜랙터도 그 청크를 해제하지 않기 때문에 현대적 언어에서도 메모리 누수는 문제가 된다.
 - 경우(프로그램 실행시간이 짧은 등)에 따라서 free를 하지 않아도 될 것으로 보일 수 있다. 하지만 이는 나쁜 버릇으로, 장기적으로 프로그래머로서 좋은 습관을 만들어야 한다. 
>프로세스 종료하면 왜 메모리누수가 일어나지 않는가?  
실행시간이 짧은 프로그램 작성후 종료직전 free를 호출하지 않는다해서 손해를 보지 않는다. 운영체제는 프로세스가 종료되거나 다른 이유로 죽을 때 메모리를 되돌려받는다. 누수되었더라도 모든 메모리를 회수한다.  
짧은 프로그램의 경우 메모리 누수는 어떠한 동작적 문제도 일으키지 않는 경우가 대부분이다. Web서버나 데이터관리 시스템같이 절대 종료하지 않는 코드의 작성시 누수메모리는 훨씬 심각한 문제며, 메모리를 다 소진하면 크래시를 일으킨다.

### 메모리 사용이 끝나기 전 메모리 해제
때때로 메모리 사용이 끝나기 전 해제한다. 이를 dangling point라 하며, 해제 후 그 포인터를 사용하면 프로그램을 크래시 시키거나 유효 메모리를 덮어쓸 수도 있다.  
예를 들어 free 호출 후 다른 용도로 malloc을 호출하면 잘못 해제된 메모리를 재사용한다.


### 반복적으로 메모리 해제
메모리를 한 번 이상 해제하는 이중 해제(double free)의 결과는 예측하기 어렵다.  
메모리 할당 라이브러리는 어쩔줄 몰라하며 이상한 일을 하게 된다. 가장 흔히는 크래시가 난다.


### free() 잘못 호출하기
유효하지 않는 해제(invalid frees)는 매우 위험하고 당연히 피해야한다.


## 5. 운영체제의 지원
malloc과 free는 라이브러리 함수이므로 시스템콜은 언급하지 않았다.  
라이브러리 자체는 시스콜을 기반으로 구축된다.   

그런 시스템 콜 중 하나가 brk이다.
- brk는 프로그램의 break 위치를 변경하는 데 사용된다. 
- brk는 새로운 break 주소를 나타내는 한 개의 인자를 받는다
- 새로운 break가 현재의 break보다 큰지 작은지에 따라 힙의 크기를 증가/감소시킨다. 
- sbrk는 증가량만을 받아들이는 것을 제외하고 비슷하게 사용된다.

brk 또는 sbrk를 직접 호출해선 안된다. 이들은 메모리 라이브러리에 의해 사용된다.  
직접 사용하면 감당할 수 없는 결과가 발생한다. 반드시 malloc() 및 free()를 사용하자.  

mmap()함수
- 운영체제로부터 메모리를 얻을 수 있다. 
- 올바른 인자를 전달하면 프로그램에 anonymous메모리영역을 만든다. 
- anonymous영역은 특정파일과 연결되어있지 않고 스왑공간(swap space)에 연결된 영역이다.(나중에 자세히)

## 6. 기타 함수들
- calloc()
- realloc()