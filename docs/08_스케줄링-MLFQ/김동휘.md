# 스케줄링 : 멀티 레벨 피드백 큐
Multi-level Feedback Queue; MLFQ  
가장 유명한 스케줄링 기법이다. 
- MLFQ가 해결하고자 하는 문제
	1. 짧은 작업을 먼저 실행시켜 반환 시간을 최적화 하자.  
   		앞 단원 마지막에서 말했듯, 운영체제는 실행 시간을 미리 알 수 없다.
	2. 대화형 사용자(화면앞에서 프로세스의 종료를 기다리는 사용자)에게 응답이 빠른 시스템이라는 느낌을 주자.  
</br>
프로세스에 대한 정보가 없다면 이러한 스케줄러를 어떻게 만들 수 있는가?  
실행중인 작업의 특성을 알아내고 이를 이용하여 더 나은 스케줄링 결정을 하기 위한 방법은 무엇인가?  
</br>
</br>
<정보 없이 스케줄링 하기?>
</br>
</br>
## 1. MLFQ 기본 규칙
멀티 레벨 피드백 큐의 기본알고리즘을 설명한다.  
여러 개의 MLFQ가 구현되어 있으나 기본적으로 비슷한 특징이 있다.  
- 여러 개의 큐로 구성되며, 각각 다른 우선순위(priority level)가 배정됨.
- 우선순위를 활영하여, 높은 우선순위 큐에 존재하는 작업이 선택된다. 
- 같은 우선순위를 가진다면 큐에 둘 이상의 작업이 존재할 수 있다. 이 작업에는 라운드 로빈(RR)알고리즘이 사용된다.
- 핵심은 각 작업에 고정된 우선순위가 아닌, 각 작업의 특성에 따라 동적으로 우선순위를 부여한다는 것.  
  ex_어떤 작업의 키보드 입력을 기다리며 반복적으로 CPU를 양보하면 해당 작업의 우선순위를 높게 유지한다.  
  ex_한 작업의 긴 시간 CPU를 집중적으로 사용하면 우선순위를 낮춘다.  
</br>
### 기본 규칙
- 규칙 1. Priority(A) > Priority(B)이면 A가 실행된다. (B실행 x)
- 규칙 2. Priority(A) = Priority(B)이면 A와 B는 RR방식으로 실행된다.  

## 시도1: 우선순위 변경
작업의 우선순위를 변경하는 것은 곧 작업이 존재할 큐를 결정하는 것  
짧은 실행시간을 갖는 CPU를 자주 양보하는 대화형 작업, 많은 CPU시간을 요구하나 응답 시간은 안중요한 긴 실행시간의 CPU위주 작업이 혼재되어 있다. 
- 규칙 3. 작업이 시스템에 진입하면 가장 높은 우선순워(맨 위 큐)로 설정
- 규칙 4_1. 주어진 타임슬라이스를 모두 사용하면 우선순위가 낮아진다.(한 단계 아래 큐로)
- 규칙 4_2. 타임슬라이스 소진 전 CPU를 양도하면 같은 우선순위를 유지.
</br>
</br>
### 알고리즘의 주요 목표  
스케줄러는 작업의 길이를 알 수 없기에, 일단 짧은 작업이라 가정하여 높은 우선순위를 부여한다. 진짜 짧은 작업이면 빨리 실행되고 종료될 것이며 짧은 작업이 아니면 천천히 아래 큐로 이동하며 스스로 긴 배치형 작업임을 증명하게 된다.  
</br>

## 현재 MLFQ의 문제점
1. 기아상태(starvation) : 
시스템에 너무 많은 대화형 작업이 존재하면 그들이 모든 CPU시간을 소모하게 될 것이고 따라서 긴 실행시간 작업은 CPU시간을 할당받지 못하게 될 것이다. (굶어 죽는다)
2. 스케줄러를 속여 지정된 몫보다 더 많은 시간을 할당하게 할 수 있다. 즉, 공격에 취약하다.  
	타임슬라이스가 끝나기 직전 아무 파일을 대상으로 입출력 요청을 내려 CPU를 양도하며 더 높은 퍼센트의 CPU시간을 얻는다. 제대로 되면 CPU를 거의 독점할 수 있다.
3. 프로그램은 시간 흐름에 따라 특성이 변할 수 있다. CPU 위주 작업이 대화형 작업으로 바뀐다면 다른 대화형 작업들과 같은 대우를 받는다.

</br>
</br>

## 시도2: 우선순위의 상향 조정
기아문제 방지를 위해 어떻게 해야 할 것인가  
주기적으로 모든 작업의 우선순위를 상향 조정(boost)하는 것이다.  
- 규칙 5. 일정 기간 S가 지나면 시스템의 모든 작업을 최상위 큐로 이동시킨다.  

### 효과
1. 프로세스가 굶어죽지 않는다.  
   최상위 큐에 존재하는 동안 작업은 다른 높은 우선수위 작업들과 RR방식으로 CPU를 공유하며 서비스를 받는다.
2. CPU 위주의 작업이 대화형 작업으로 특성이 변할 경우 우선순위 상향을 통해 스케줄러가 변경된 특성에 적합한 스케줄링 방법을 적용한다.  
</br>
- S는 얼마로 해야 하는가?  
  이러한 값을 부두 상수(voo-doo constants)라고 부른다. 이를 정확히 결정하기 위해서는 흑마술이 필요한 것처럼 보이기 떄문이다.  
  너무 크면 긴 실행시간을 가져 작업이 굶을 수 있으며, 너무 작으면 대화형 작업이 적절한 양의 CPU시간을 사용할 수 없다.  
</br>
</br>

## 시도 4: 더 나은 시간 측정
또하나의 문제, 스케줄러를 자신에게 유리하게 동작시키는 것을 어떻게 막을 것인가?  
작업이 타임슬라이스가 끝나기 전에 CPU를 양보하여 우선순위를 유지 가능하게 한다.
</br>
### 해결책
MLFQ의 각 단계에서 CPU 총 사용시간을 측정한다.  
스케줄러는 헌재 단계에서 프로세스가 소진한 CPU시간을 저장한다. 프로세스가 타임슬라이스 시간을 모두 소진하면 다음 큐로 강등된다.  
타임 슬라이스를 한 번에 소진하든 짧게 여러 번 소진하든 상관없다. 
- 규칙 4. 주어진 단계에서 시간 할당량을 소진하면(CPU 양도 횟수와 상관없이) 우선순위는 낮아진다.  

## MLFQ 조정과 다른 쟁점들
여러 다른 쟁점들이 남아있다. 필요한 변수들을 스케줄러가 어떻게 설정해야 하는가? 예를들어 몇 개의 큐가 존재해야 하는가? 큐당 타임슬라이스의 크기는? 기아를 피하고 변화를 반영하기 위해 우선순위 상향조정을 얼마나 자주해야 하는가?  
</br>
해결방안의 예시
- 대부분의 MLFQ는 큐 별로 타임슬라이스를 변경할 수 있다. 우선순위가 높은 큐는 보통 짧은 타임슬라이스가 주어진다.  
- 수학공식을 사용하여 우선순위를 조정한다. 우선순위 계산을 위해 프로세스가 사용한 CPU시간을 기초로 한 공식(감쇠-사용;decay-usage)을 사용한다. 
- 스케줄러들은 다른 여러 기능을 제공한다. 가장 높은 우선순위를 운영체제 작업으로 예약해 두기도 한다. 일반적인 사용자 작업은 시스템 내의 가장 높은 우선순위를 가질 수 없다. 일부 시스템은 사용자가 우선순위를 조작할 수 있는 도구를 제공한다.

