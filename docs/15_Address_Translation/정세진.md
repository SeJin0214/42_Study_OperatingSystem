## 현대 운영체제의 목표

- 효율성
    - 실행 프로그램에게 방해되지 않게 최선을 다한다.
- 제어
    - 중요한 순간에 운영체제가 관여하여 하드웨어를 직접 제어한다.
    

## 메모리 가상화 전략

- 메모리 가상화에서 CPU 가상화와 비슷한 전략을 추구할 것
    - 가상화를 제공하는 동시에 효율성과 제어를 모두 추구
    - 하드웨어의 지원을 최대한 활용(레지스터, TLB, 페이지 테이블 등)

> 프로그래머가 원하는 대로 주소 공간을 사용하고, 프로그래밍하기 쉬운 시스템을 만들기 원한다.
> 

<aside>
💡 어떻게 효율적이고 유연하게 메모리를 가상화하는가?

1. 프로그램이 필요로 하는 유연성을 어떻게 제공하는가?
2. 프로그램이 접근할 수 있는 메모리의 위치에 대한 제어를 어떻게 유지하는가?
3. 메모리 접근을 어떻게 적절히 제한할 수 있는가?
</aside>

## 하드웨어-기반 **주소 변환**(hardware-based address translation)

<aside>
💡 주소 변환을 통해 **하드웨어는 가상 주소를** 정보가 실제 존재하는 **물리 주소로 변환**

</aside>

- 가상화의 목표
    - 운영체제는 프로그램이 메모리 주소 0부터 시작하여 RAM의 최대치까지 접근할 수 있다고 생각하게 만든다.

일단 비현실적인 가정을 세우고 시작

1. 사용자 주소 공간은 물리 메모리에 연속적으로 배치되어야 한다고 가정

운영체제는 프로그램의 데이터를 메모리 주소 0이 아닌, **다른 곳으로 재배치 하고 싶어** 한다. 

## 동적 (하드웨어 -기반) 재배치 or 베이스와 바운드

- base 레지스터와 **limit 레지스터(프로그램이 접근 가능한 최대 주소)** 사용
    - 원하는 위치에 주소 공간만 사용할 수 있다.
    - limit 레지스터 방식
        1. **주소 공간의 크기를 저장**하는 방식, **가상 주소를** 베이스 레지스터에 더하기 전에 **limit 레지스터와 비교**
        2. 주소 공간의 마지막 물리 주소를 저장하는 방식, 베이스 레지스터를 더하고 바운드 안에 있는 지 검사

 

프로그램 시작을 위해 일어나는 일

1. 디스크에서 프로그램을 읽어 온다.
2. 메모리에 올릴 때, 물리 메모리 위치를 정한다.
3. 0과의 offset 값을 base 레지스터에 load 한다. (x86-16에서 exe 파일을 실행할 때, 헤더에 적혀 있는 값으로 PC와 세그먼트 레지스터를 보정해주는 것과 비슷한 행동을 한다)
4. physical address = virtual address + base(offset)
5. 앞으로 레지스터에서 load, store 등을 할 때마다, offset 값이 적혀 있는 base 레지스터의 값과 가상 메모리 주소를 더해 물리 메모리 주소에서 활동할 수 있게 된다. 
6. 이것을 **주소 변환**이라 한다.

> 옛날에 하드웨어 지원이 제공되기 전, 주먹구구식으로 재배치를 수행했다.
> 
> 
> 모든 데이터를 옮기고 싶은 주소의 offset 만큼 더하는 것이다.
> 
> 이는 여러 단점이 있지만, 대표적으로 메모리 보호 기능이 없다는 단점이 있다.
> 

주소 변환에 도움을 주는 프로세서의 일부

**메모리 관리 장치(memory management unit, MMU)**

주소에서 벗어나는 곳을 접근하려 하면 **예외를 발생시켜야 함(보통 종료)**

## 운영체제 이슈

운영체제가 반드시 개입해야 하는 중요한 시점 3가지

1. 프로세스가 생성될 때, 어느 주소 공간에 저장할 지 찾아야 함
    1. 빈 공간 리스트에서 검색한다. (가변 크기인 경우는 나중에…)
2.  프로세스가 종료할 때
    1. 정상 종료 또는 잘못된 행동인 경우 강제 종료하여 메모리를 회수
    2. 회수한 메모리는 다시 빈 공간 리스트에 넣는다.
3. 문맥 교환이 일어날 때
    1. PCB 안에 사용했던 레지스터 값을 넣어야 함
4. CPU의 예외를 처리할 수 있어야 한다. 

### 요약

지금 까지 이야기 나눈 것은 **제한적 직접 실행의 기본적인 접근 방식**

> 주소 변환을 사용하면 운영체제는 프로세스의 모든 메모리 접근을 제어할 수 있고, 접근이 항상 주소 공간의 범위 내에서 이루어지도록 보장할 수 있다.
> 

하드웨어의 지원아 고마워~~~ 너 없었으면 메모리 가상화 하기 힘들었어~

프로세스 내부의 메모리가 단편화 되어 낭비가 발생하면 내부 단편화

내부 단편화를 방지하기 위해 일반화된 베이스-바운드 기법인 세그멘테이션을 다음 장에서 볼 것

### 여담

- 빈 공간 리스트
    - 프로세스에게 메모리를 할당해주기 위해, 사용되지 않는 메모리 공간을 리스트로 유지한다.

### 좀 더 찾아볼 것

TLB

MMU

프로세스 테이블

### 문제 제작

1. 주소 변환의 이점
2. 빈 공간 리스트는 무엇인가?
3. 메모리 가상화의 목표는?