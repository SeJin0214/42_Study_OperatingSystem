# 주소 변환의 원리
이전에 CPU가상화 부분에서 제한적 직접 실행(LDE)이라는 기법을 다룬적 있다.
> LDE란?  
> 보통 프로그램은 하드웨어에서 실행되지만, 프로세스가 시스템 콜 호출하거나, 타이머 인터럽트 발생 등 특정 순간 운영체제가 개입하여 문제가 발생하지 않도록 함. 즉, 중요한 순간에 운영체제가 하드웨어를 직접 제어한다.

메모리 가상화에서 비슷한 전략을 추구힌다.  
- 가상화 제공
- 효율성(efficiency) 추구
  - 하드웨어 지원 활용 필요
    - 몇 개의 레지스터(를 사용하는 것 부터)
    - TLB
    - 페이지 테이블
    - (등, 점차 복잡한 하드웨어 사용할듯)
- 제어(control) 추구
  - 자신 이외의 메모리에 접근불가하도록 운영체제가 보장하는 것.
  - 프로그램이나 운영체제를 타 프로젝트로부터 보호하기 위해 하드웨어 도움이 필요.
- 유연성(flexibility)
  - 프로그래머가 원하는 대로 주소 공간을 사용하고 프로그래밍하기 쉬운 시스템을 만들기.
</br>
</br>

우리가 다룰 기법은 하드웨어-기반 주소 변환(hardware-based address translation) 또는 짧게 주소변환이라고 한다.  
- 이 기술은 제한적 직접실행 방식에 부가적으로 사용되는 기능이라고 볼 수 있다.
  - 주소 변환을 통해 하드웨어는 명령어 반입, 탑재, 저장등 가상주소를 정보가 실제로 존재하는 물리주소로 변환한다. 
  - 프로그램의 모든 메모리 참조를 실제 메모리 위치로 재지정하기 위해 하드웨어가 주소를 변환한다.
- 정확한 변환은 운영체제가 관여해야 한다.
  - 하드웨어에 의해 제공되는 저수준 기능은 주소변환 가속화에 도움은 주나, 정확한 변환을 위해선 운영체제가 필요하다.
  - 운영체제는 메모리의 빈 공간을 알고있고, 메모리 사용을 제어 및 관리한다.

모든 작업의 목표는 다음과 같다
- 프로그램이 자신의 전용 메모리를 소유하고 그 안에 자신의 코드 및 데이터가 있다는 `환상`을 만드는 것이다.

</br>
</br>

## 1. 가정
당분간 아래와 같이 가정한다. 
- 사용자 주소공간은 물리메모리에 연속적으로 배치된다.
- 주소공간은 물리메모리 크기보다 작다
- 각 주소 공간의 크기는 같다.
비현실적이나, 논의를 진행하며 가정들을 완화하여 실질적 메모리가상화를 이끌어낼 것이다.
</br>
</br>

## 2. 사례
주소 변환 구현을 위해 어떤 것이 필요한지, 왜 그런 기법이 필요한지를 예를 들어 설명한다.

메모리에서 값을 탑재하고, 3을 증가시키고, 다시 메모리에 저장하는 짧은 코드가 있다.
```c
void func()  
{  
	int x = 3000;  
	x = x + 3;  
}  
```

```sh
128 : movl	0x0(\%ebx), \%eax ;	# 0 + ebx를 eax에 저장  
132 : addl	0x03, \%eax ;			# eax 레지스터에 3 저장  
135 : movl	\%eax, 0x0(\%eax) ;	# eax를 다시 메모리에 저장  
```

- x의 주소는 레지스터 ebx에 저장되어 있다고 가정
- 이 주소에 저장된 값을 movl 명령어를 사용하여 범용레지스터 eax에 넣기
- eax에 3을 더하기
- eax값을 같은 위치의 메모리에 저장.  
	<img src="image\image01.png" width="300" height="700">  
위 그림을 참고할 수 있다. 
- 주소 128의 명령어를 반입
  - 이 명령어 실행 (주소15KB에서 탑재)
- 주소 132의 명령어를 반입
  - 이 명령어 실행 (메모리 참조 없음)
- 주소 135의 명령어를 반입
  - 이 명령어 실행 (15KB에 저장)

프로그램 관점에서 주소공간은 0에서 시작하여 최대 16KB까지이다.  
프로그램이 생성하는 모든 메모리 참조는 이 범위 내에 있어야 한다. 
메모리 가상화를 위해 운영체제는 프로세스를 물리주소 0이 아닌 다른 곳에 위치시키고 싶다.  

> 어떻게 하면 프로세스 모르게 메모리를 다른 장소로 재배치할 수 있을까?

>프로세스 주소공간이 실제로는 다른 물리주소에 배치되어 있을때 주소 0부터 시작하는 가상 주소공간의 환상을 어떻게 제공할 수 있을까?  

</br>
아래는 프로세스의 주소공간이 메모리에 배치되었을 때 가능한 물리메모리 배치의 한 예
<img src="image\image02.png" width="300" height="400">  

- 물리 메모리 첫 번째 슬롯은 운영체제 자신이 사용하는 것을 확인할 수 있음
- 프로세스는 물리주소 32KB에서 시작하는 슬롯에 재배치된 것을 볼 수 있음

</br>
</br>

## 3. 동적(하드웨어-기반) 재배치
하드웨어 기반의 주소변환을 이해하기 위한 첫 번째 실현사례를 설명한다  

#### 베이스와 바운드(base and bound) == 동적 재배치(dynamic relocation)
- 각 CPU마다 2개의 하드웨어 레지스터가 필요하다.
  - 베이스 레지스터
  - 바운드 레지스터 (한계 레지스터)
- 이 베이스-바운드 쌍은 우리가 원하는 위치에 주소공간을 배치하도록 한다.
- 또한 배치와 동시에 프로세스가 오직 자신의 주소공간에만 접근하도록 한다.

- 과정
  1. 각 프로그램은 주소 0에 탑재되는 것처럼 작성 및 컴파일된다.
  2. 프로그램 시작 시 -> 운영체제가 물리메모리 위치를 결정하고 `베이스 레지스터`를 그 주소로 지정한다.
       - 위 그림에서는 운영체제가 프로세스를 물리주소 32KB에 저장하기로 결정하고 베이스 레지스터를 이것으로 설정한다.
  3. 프로그램 실행 중 -> 프로세스에 의해 생성되는 모든 주소가 다음과 같이 변환된다.
		> 물리주소 = 가상주소 + 베이스
       - 프로세스가 생성하는 메모리 참조주소는 가상주소이며, 하드웨어는 베이스 레지스터의 내용을 더해 물리주소를 생성한다.


		앞선 예시
		```c
		128: mov1 0x0 (%EBX), % eax
		```
		- 프로그램 카운터(PC) : 128
		- 베이스 레지스터의 값 : 32KB (32768)
		- 물리 주소 : 32896 (= 128 + 32768)

</br>
</br>

### 바운드(한계) 레지스터는?

- 보호를 지원하기 위해 존재한다. 
  - 프로세스가 메모리 참조가 합법적인가를 확인하기 위해 가상주소가 바운드 안에 있는지 확인한다.
    - 앞선 예에서 바운드 레지스터는 항상 16KB로 설정된다. 
  - 프로세스가 바운드보다 큰 가상주소 또는 음수인 가상주소를 참조하면 CPU가 예외를 발생시켜 프로세스가 종료된다.
- 즉, 프로세스가 생성한 모든 주소가 합법적이고 프로세스의 "범위"에 있다는 것을 확인하는 역할.

</br>
</br>

#### 메모리 관리장치(memory management unit; MMU)
베이스 & 바운드 레지스터는 CPU칩 상에 존재하는 하드웨어 구조임. (CPU당 1쌍)

- `MMU` : 주소변환에 도움을 주는 프로세서의 일부
- 더 정교한 메모리 관리 기법을 개발할 수록 MMU에 더 많은 회로를 추가하게 된다.

</br>
</br>

## 4. 하드웨어 지원: 요약

필요한 하드웨어 지원을 요약해 본다.  

<img src="image\하드웨어요구사항.png" width="500" height="300">  

- `두 가지 CPU모드` 필요
  1. 특권 모드(커널 모드) : 운영체제가 실행하며 컴퓨터 전체 접근 권한을 가짐.
  2. 사용자 모드 : 응용프로그램이 실행되며, 제한이 있다. 
  - 프로세서 상태 워드(processor status word)레지스터의 한 비트가 CPU의 현재 실행 모드를 나타냄.
  - 특정 순간(시스템 콜 또는 예외나 인터럽트 발생)에 CPU는 모드를 전환한다.
- 하드웨어는 `베이스 & 바운드 레지스터`를 자체제공
  - CPU는 메모리관리장치(MMU)의 일부인 추가 레지스터쌍을 가진다. 
  - 프로그램 실행중인 경우 하드웨어는 프로그램이 생성한 가상주소 + 베이스값 = 주소변환한다. 
  - 하드웨어가 주소가 유효한지 검사하기 위해 바운드 레지스터와 CPU내 일부 회로를 사용한다. 
- 하드웨어는 `베이스 & 바운드 레지스터값을 변경하는 명령어`를 제공
  - 다른 프로세스 실행시 운영체제가 이 특권명령어를 사용하여 베이스 & 바운드 값을 변경할 수 있다.
  - 특권 명령어이기 때문에 커널모드(또는 특권모드)에서만 변경할 수 있다.
- CPU는 사용자 프로그램이 바운드를 벗어나 불법적 메모리 접근을 시도할 경우 `예외를 발생`시킴.
  - 사용자 프로그램의 실행을 중지하고 운영체제의 "바운드 벗어남" 예외 핸들러(exception handler)가 실행되도록 조치한다.
  - 운영체제 핸들러는 대처를 결정하며, 보통 프로세스를 종료시킨다.
  - 사용자 프로그램이 특권이 필요한 베이스 & 바운드 값 변경을 시도하면 CPU는 예외를 발생시키며 "사용자모드에서의 특권 연산 발생" 핸들러를 실행시킨다.
    - CPU는 핸들러들의 주소를 파악하기 위해 몇 개의 특권명령어가 더 필요하다.

</br>
</br>

## 5. 운영체제 이슈
동족 재배치 지원을 위해 (앞서 하드웨어가 가능을 제공하는 것 처럼) 운영체제에도 새로운 이슈가 등장한다.  
하드웨어 지원과 운영체제 관리가 결합되면 간단한 가상메모리를 구현할 수 있다.
</br>
</br>

베이스 & 바운드 방식의 가상메모리를 구현할 때 운영체제가 반드시 개입돼야 하는 3개의 시점이 존재한다.
### 운영체제 개입시점
1. 프로세스 생성시
	- 주소공간이 저장될 메모리 공간을 찾아 조치를 취해야 함.
	- 각 주소공간은 "물리 메모리 크기보다 작고", "크기가 일정하다"라는 초반의 가정하에 쉽게 처리 가능
	- 운영체제가 물리메모리를 슬롯의 배열로 보고 각 슬롯 사용여부를 관리
	- 새로운 프로세스 생성시 사용가능한 영역을 찾기 위해 빈공간 리스트(free list)라 불리는 자료구조를 검색해야한다.
    	- 검색을 통해 선택된 공간은 사용중이라 표시한다. 
    	- 가변 크기 주소공간은 더 복잡해진다 (나중에 배움)
2. 프로세스 종료시
	- 정상종료 or 잘못된 행동으로 강제종료될 때 사용하던 메모리를 회수하여 다른 프로세스나 운영체제가 사용가능하도록 해야 함.
    	- 프로세스 종료시 운영체제는 종료한 프로세스 메모리를 다시 빈공간 리스트에 넣고 연관된 자료구조를 모두 정리
3. 문맥교환 발생시
	- CPU마다 한 쌍의 베이스-바운드만 존재하고 각 프로그램은 다른 물리주소에 탑재되어야 하기에 프로그램마다 다른 값을 가진다.
	- 운영체제는 프로세스 전환시 베이스와 바운드 쌍을 저장 및 복원해야 한다.
    	- 실행중인 프로세스를 중단시키려하면 메모리에 존재하는 프로세스별 자료구조 속 베이스&바운드값을 저장해야 함.
    	- 이 자료구조는 프로세스 구조체(process structure)또는 프로세스 제어 블록(process control block, PCB)라고 불린다. 
	-  실행중인 프로세스를 재시작, 또는 처음 실행시킬 때 이 프로세스에 맞는 값으로 베이스 & 바운드 값을 설정해야 한다.
	-  프로세스의 주소공간을 이동시키려면 
		1. 운영체제가 프로세스의 실행을 중지시킨다.
         	-  프로세스 중단시 주소공간을 옮기기 더 쉽기 때문.
		2. 현재 위치에서 새 위치로 주소 공간을 복사한다.
		3. 프로세스 구조체에 저장된 베이스 레지스터를 갱신하여 새 위치를 가리키도록 한다.
		4. 프로세스가 실행을 재개하면 새로운 베이스 레지스터가 복원되고 다시 실행을 시작한다.
			- 이때 명령어와 데이터가 전혀 다른 새 위치에 존재한다는 사실을 인식하지 못한다.
4. 운영체제는 예외 핸들러 또는 호출될 함수를 제공해야 함
   - 부싱시 특권명령어를 사용하여 이 핸들러를 설치한다.
     - ex_ 프로세스가 바운드 밖 메모리에 접근하려는 경우 -> CPU가 예외 발생시킴
   - 운영체제는 이러한 예외 발생시 조치를 취할 준비가 되어 있어야 함.
     - 일반적 대응은 적대적 양상을 띈다. -> 보통 종료시킨다.

	- 아래 그림은 하드웨어/OS간 상호작용을 타임라인으로 보여준다.
    	- 부팅을 할 때 컴퓨터를 사용가능 상태로 만들기 위해 운영체제가 뭘 하는지
    	- 프로세스 A를 시작할 때 무슨일이 일아나는지
<img src="image\제한된실행프로토콜.png" width="550" height="700">  

</br>
</br>

   - 우리는 아직 제한적 직접 실행의 기본적 접근방식을 따른다. 
     - 운영체제는 하드웨어를 적절히 설정하고 프로세스가 CPU에서 직접 실행할 수 있게 한다.
     - 또한, 프로세스가 잘못된 행동을 헀을때만 운영체제가 개입해야 한다.