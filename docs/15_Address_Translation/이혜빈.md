# 18. 주소 변환의 원리

> 메모리 가상화의 목표 ; 가상화를 제공하는 동시에 효율성과 유연성, 제어 모두를 추구.  
> 어떻게??  
-> 하드웨어-기반 주소 변환(hardware-based address translatoin), 주소변환(address translation)기법을 사용.

이 주소 변환 기법은 LDE에 부가적으로 사용되는 기능.  
주소 변환을 통해 하드웨어는 명령어 반입, 탑재, 저장 등의 가상 주소를 실제 물리 주소로 변환함.

우리의 목표 : 프로그램이 자신의 전용 메모리를 소유하고 그 안에 자신의 코드와 데이터가 있다는 환상을 만드는 것.  
-> 이걸 운영체제가 해야 함.

## 18.1 가정
1. 주소공간은 물리적 메모리에 연속적으로 존재함.
2. 주소공간의 크기는 실제 물리 메모리보다 작다.
3. 각 주소공간은 정확히 같은 크기를 가진다.

## 18.2 예시

```c
void func()
{
	int x = 3000;
	x = x + 3;
}
```

```assembly
128 : movl 0x0(%ebx), %eax; //레지스터 ebx에 저장된 x주소를 메모리 eax에 올린다.
132 : addl $0x03, %eax; // 메모리 eax에 3을 더한다.
135 : movl %eax, 0x0(%ebx); // eax의 값을 레지스터 ebx로 옮긴다.
```

위 코드는 아래와 같은 어셈블리어로 동작한다.  
중요한 것은 주소공간은 0에서 최대 16KB라는 것이다. 어떻게 실제 주소를 제한된 공간의 가상 주소에 옮길 수 있을까?

## 동적 재배치
베이스 바운드 아이디어.  
두개의 하드웨어 레지스터 이용. 하나는 베이스, 하나는 바운드(=limit)  
이 두개의 레지스터는 위락 원하는 위치에 주소 공간을 배치할 수 있게 하면서 자신의 주소 공간에만 접근하도록 한다.  

베이스는 실제 물리공간의 시작 주소이다.  
즉, 물리 주소 = 가상 주소 + 베이스가 된다.  
이 간단한 더하기가 가상주소 -> 물리주소 가 되는 ㄱ미술이다. 이 재배치는 실행 시, 실행을 시작한 이후에도 일어나므로 동적 재배치가 가능하다.

그렇다면 바운드는?  
바운드는 보호를 위한 레지스터.  
물리주소의 마지막이 바운드이므로,  
가상주소 + 베이스의 값이 바운드를 벗어난다면 CPU는 예외를 발생시키고 프로세스를 종료한다.  
즉, 바운드는 프로세스의 범위를 확인하는 것.

이렇게 주소변환에 도움을 주는 프로세서(하드웨어)의 일부 장치를 메모리 관리 장치, MMU라고 부른다.