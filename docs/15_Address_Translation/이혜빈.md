# 18. 주소 변환의 원리

> 메모리 가상화의 목표 ; 가상화를 제공하는 동시에 효율성과 유연성, 제어 모두를 추구.  
> 어떻게??  
-> 하드웨어-기반 주소 변환(hardware-based address translatoin), 주소변환(address translation)기법을 사용.

이 주소 변환 기법은 LDE에 부가적으로 사용되는 기능.  
주소 변환을 통해 하드웨어는 명령어 반입, 탑재, 저장 등의 가상 주소를 실제 물리 주소로 변환함.

우리의 목표 : 프로그램이 자신의 전용 메모리를 소유하고 그 안에 자신의 코드와 데이터가 있다는 환상을 만드는 것.  
-> 이걸 운영체제가 해야 함.

## 18.1 가정
1. 주소공간은 물리적 메모리에 연속적으로 존재함.
2. 주소공간의 크기는 실제 물리 메모리보다 작다.
3. 각 주소공간은 정확히 같은 크기를 가진다.

## 18.2 예시

\<C>

```c
void func()
{
	int x = 3000;
	x = x + 3;
}
```

\<assembly>


```assembly
128 : movl 0x0(%ebx), %eax; //레지스터 ebx에 저장된 x주소를 메모리 eax에 올린다.
132 : addl $0x03, %eax; // 메모리 eax에 3을 더한다.
135 : movl %eax, 0x0(%ebx); // eax의 값을 레지스터 ebx로 옮긴다.
```

위 코드는 아래와 같은 어셈블리어로 동작한다.  
중요한 것은 주소공간은 0에서 최대 16KB라는 것이다. 어떻게 실제 주소를 제한된 공간의 가상 주소에 옮길 수 있을까?

## 동적 재배치
베이스 바운드 아이디어.  
두개의 하드웨어 레지스터 이용. 하나는 베이스, 하나는 바운드(=limit)  
이 두개의 레지스터는 위락 원하는 위치에 주소 공간을 배치할 수 있게 하면서 자신의 주소 공간에만 접근하도록 한다.  

베이스는 실제 물리공간의 시작 주소이다.  
즉, 물리 주소 = 가상 주소 + 베이스가 된다.  
이 간단한 더하기가 가상주소 -> 물리주소 가 되는 ㄱ미술이다. 이 재배치는 실행 시, 실행을 시작한 이후에도 일어나므로 동적 재배치가 가능하다.

그렇다면 바운드는?  
바운드는 보호를 위한 레지스터.  
물리주소의 마지막이 바운드이므로,  
가상주소 + 베이스의 값이 바운드를 벗어난다면 CPU는 예외를 발생시키고 프로세스를 종료한다.  
즉, 바운드는 프로세스의 범위를 확인하는 것.

이렇게 주소변환에 도움을 주는 프로세서(하드웨어)의 일부 장치를 메모리 관리 장치, MMU라고 부른다.

## 필요한 하드웨어 지원

먼저 cpu를 가상화 하는데 커널모드, 유저모드 두 가지 모드가 필요하다. 이 모드는 하드웨어의 프로세서 상태워드 레지스터의 한 비트가 0과 1로 현재 실행 모드를 나타낸다.  
또한 하드웨어는 베이스와 바운드 레지스터를 자체적으로 제공하며 이는 cpu의 mmu(메모리 관리 장치)의 일부로  사용된다.

<동적 재배치에서 하드웨어에게 필요한 요구사항>
하드웨어 요구사항 | 노트
---|---
특권모드| 사용자 모드 프로세스가 특권 연산을 실행하는 것을 방지하기 위해 필요
베이스/바운드 레지스터|주소 변환과 범위 검사를 지원하기 위하여 CPU당 한 쌍의 레지스터가 필요
가상 주소를 변환하고 범위 안에 있는지 검사하는 능력 | 주소 변환과 범위 검사를 위한 회로. 매우 간단
베이스/바운드를 갱신하기 위한 특권 명령어 | 운영체제가 예외 처리 코드를 하드웨어에게 알려줄 수 있어야 함
예외 발생 기능 | 프로세스가 특권 명령어 실행을 시도하거나 범위를 벗어난 메모리의 접근을 시도할 때 예외를 발생시킬 수 있어야 함

## 18.5 운영체제 이슈
운영체제도 새로운 이슈가 발생함.  
베이스 바운드 방식의 가상 메모리 구현을 위해 운영체제가 반드시 개입되어야 하는 중요한 세 개의 시점.
1. 프로세스가 생성될 때 운영체제는 주소공간이 저장될 메모리 공간을 찾아 조치를 취해야 함.
2. 프로세스가 정상적, 혹은 강제적으로종료할 때 프로세스가 사용하던 메모리를 회수해야 함.
3. context swiching이 일어날 때도 추가적인 조치 필요.
	- 프로세스가 전환될 때마다 각 프로세스의 베이스/바운드 쌍을 저장, 복원 해야함.
	- 저장되는 곳은 프로세스 제어 블록, PCB
4. 운영체제는 에외핸들러를 제공해야 함.

실제 프로그램 실행에서 하드웨어/OS의 상호작용을 보면 메모리 변환은 OS의 개입 업싱 하드웨어에서 처리된다.  
대부분의 경우 OS는 하드웨어를 적절하게 설정하고 프로세스가 CPU에서 직접 실행되게 한다. 다만, 프로세스가 잘못된 행동을 하는 경우에만 OS가 개입하여 예외를 발생시킨다.

## 18.6 요약
주소변환을 사용하면 운영체제는 프로세스의 모든 메모리 접근을 제어할 수 있고, 접근이 항상 주소 공간의 범위 내에서 이루어지도록 보장할 수 있다. 핵심은 하드웨어의 지원.  
하드웨어의 지원으로 가상주소를 물리주소로 빠르게 변환할 수 있다.  
베이스와 바운드를 이용한 가상화는 매우 효율적이고 프로세스가 자신의 주소 외의 메모리에는 접근하지 못하게 하는 보호 기능도 제공한다.  
동적 재배치는 비효율 적이고, 내부 단편화 현상을 야기한다.