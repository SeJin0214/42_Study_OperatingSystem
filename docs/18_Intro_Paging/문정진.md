# 페이징 : 개요

> 세그멘테이션은  공간을 다양한 크기의 청크로 분할해 단변화가 발생, 추후 할당이 점점 어려워짐  
> 페이징 : 공간을 동일 크기의 조각으로 분할. 프로세스의 주소 공간을 몇 개의 가변 크기가 아닌 고정 크기 단위로 나눔.
> 페이지 : 페이징을 통해 고정 크기로 나눈 각각의 단위를 페이지라고 불림.
> 페이지 프레임 : 고정 크기의 슬롯의 배열.

## 21.1 간단한 예제 및 개요.

* 아래 그림은 총 크기가 64바이트며 4개의 16바이트 페이지로 구성.
<img src="image\image01.png" width="300" height="300"/>

* 물리 메모리는 고정 크기의 슬롯들로 구성.
* 8개의 페이지 프레임, 총 128바이트의 작은 물리 메모리.
* 가상 주소 공간의 페이지들은 물리 메모리 전체에 분산 배치.
* 운영체제 자기자신을 위해 물리 메모리 일부 사용.

<img src="image\image02.png" width="300" height="300"/>

> 페이징 사용 시 프로세스 주소 공간 사용 방식과 상관없이 효율적으로 주소 공간 개념 지원.
> 또 다른 장점은 빈 공간 관리의 단순함. -> 64바이트의 주소 공간을 8페이지 물리 메모리 배치할 때, 운영체제는 비어있는 네 개의 페이지만 찾으면 됨.
* 운영체제니느 비어 있는 페이지의 빈 공간 리스트를 유지하고 네 개의 페이지 선택.
</br>  
> 페이지 테이블 : 주소 공간의 가상 페이지에 대한 물리 메모리 위치 기록, 운영체제는 프로세스 마다 페이지 테이블이라는 자료 구조를 갖는다.
* 페이지 테이블은 주소 공간의 가상 페이지 주소 변환 정보를 저장. -> 각 페이지가 저장된 물리 메모리 위치를 알려줌.  
* 역 페이지 테이블 이라는 예외적인 기법이 있음.  
</br>
</br>

* 프로세스가 생성한 가상 주소 변환 -> 가상 페이지 번호(VPN)과 오프셋 2개 분할.
<img src="image\image03.png" width="300" height="300"/>

* Va5 가상 주소의 최상위 비트, Va0은 최하위 비트.
<img src="image\image04.png" width="300" height="300"/>

* 페이지 크기는 64바이트의 주소 공간 경우 16바이트.
* 4페이지 선택 할 수 있어야 하며, 주소의 최상의 2비트가 그 역할함.
* 2비트 가상 페이지 번호를 갖음.
* 나머지 비트는 페이지 내에서 원하는 바이트 위치며, 오프셋으로 불림.
</br>
</br>

* "21"을 이진 형식 변환, 가상 페이지 번호와 오프셋 나눔.
<img src="image\image05.png" width="300" height="300"/>

* "21"은 가상 페이지는 "01"의 "0101" 번째의 바이트.
* 가상 페이지 번호 갖고, 페이지 테이블 인텍스 사용해, 어느 물리 프레임에 저장되어 있는지 찾을 수 있음.
</br>

* 물리 프레임 번호(PFN) 혹은 물리 페이지 번호(PPN)
* VPN을 PFN으료 교체해 가상 주소를 변환.
* 물리 메모리에 탑재 명령어 실행.

<img src="image\image06.png" width="300" height="300"/>

</br>

* 오프셋은 동일.
* 오프셋은 페이지 내에서의 원하는 위치를 알렵줌.
* 최종적으로 계산된 물리주소는 1110101. 탑재할 데이터가 정확히 저장된 위치.
</br>

## 21.2 페이지 테이블은 어디에 저장되는가.

* 작은 세그멘트 테이블이나 베이스-바운드 쌍에 비해 페이지 테이블은 커질수 있다.
* 페이지 테이블은 크기 때문에, 실행 중인 프로세스의 페이지 테이블을 저장할 수 있는 회로를 MMU안에 유지 하지 않음.
* 프로세스의 페이지 테이블은 메모리에 저장.
* 페이지 테이블은 운영체제 가상 메모리에 저장. 디스크에 스왑될 수 있음.

## 21.3 페이지 테이블에는 실제 무엇이 있는가.
* 페이지 테이블의 구성.
* 페이지 테이블
    * 가상 주소를 물리 주소로 매핑하는 자료구조.
    * 선형 페이지 테이블.
    * 물리 프레임 번호(PFN)를 찾기 위해, 가상 페이지 번호(VPN)로 배열 항목 접근. 페이지 테이블 항목(PTE)을 검색

<img src="image\image07.png" width="300" height="300"/>

* 각 PTE에는 심도있는 이해가 필요한 비트가 존재(?)
* Valid bit : 특정 변환의 유효 여보 나타내기 위해 포함됨.
* 힙이 주소 공간의 한쪽에 있고 반대쪽에는 스택이 차지하고 있으며, 그 사이에 미사용 공간을 무효(invalid)로 표기. 프로세스가 해당 메모리 접근시 트랩 발생시키며, 프로세스 종료 시킬 확률이 높음.
* Valid bit는 할당 되지 않은 주소 공간 표현을 위해 필요.
* 미사용 공간을 표시함으로 페이지에게 물리 프레임 할당할 필요 없애, 대량의 메모리 절약.
</br>

* protection bit : 페이지가 읽을 수 있는지, 쓸 수 있는지, 실행될 수 있는지 표시. 허용되지 않는 방식 접근시 트랩 생성.
</br>

* Present bit : 페이지가 물리 메모리에 있는지 혹은 디스크에 있는지.
</br>

* Dirty bit : 메모리 반입된 후 페이지 변경되었는지 여부 나타냄.
</br>

* Reference bit : 페이지가 접근 되었는지 추적하기 위해 사용. 어떤 페이지가 인기 있는지 결정해 메모리에 유지되어야 하는 페이지 결정. 해당 내용은 페이지 교체이 중요함.

## 21.4 페이징: 너무 느림.
* 페이지 테이블의 쿠기가 메모리 상에서 매우 크게 증가할 수 있으며, 그로인해 처리 속도가 저하됨.
* 데이터를 가져오기 위해 시스템은 가상 주소를 정확한 물리 주소로 변환해야함.
* 주소에서 데이터를 반입하기 전 시스템은 프로세스 페이지 테이블에서 적절한 페이지 항목을 가져와야함.
* 변환 수행 후, 물리 메모리에 데이터를 탑재.
* 해당 과정을 하기 위해서 하드웨어는 현재 실행 중인 프로세스의 페이지 테이블의 위치를 알아야함.
* 모든 메모리 참조에 대해, 페이지 테이블 변환 정보를 반입하기 때문에, 메모리 참조가 필요. 메모리 참조는 비용이 비싸고, 프로세스는 2배 이상 느려짐.
* 페이지 테이블로 인해 시스템이 느려질수 있으며 많음 메모리 차지.

## 21.5 메모리 트레이스

* 페이징 사용 시 발생하는 메모리 접근.

```c
int array[1000];

for (i = 0; i < 1000; i++)
    array[i] = 0;
```

* 해당 코드는 배열 초기화.
* 루프 안에 배열 초기화하기 위한 어셈블리어 명령어 알기 위해 디스어셈블리어

```c
0x1024 movl $0x0, (%edi, %eax, 4)
0x1028 incl %eax
0x102c cmpl $0x03e8, %eax
0x1030 jne 0x1024
```
* 첫 번째 명령어 : 값을 가상 메모리 주소로 옮김 
* 두 번째 명령어 : %eax에 저장된 배열 인덱스 증가
* 세 번째 명령어 : %eax의 값과 16진수를 1000에 비교
* 네 번째 명령어 : 루프의 상단으로 다시 분기. 

* 크기가 4000바이트, 가상 주소가 40000에서 44000까지 존재한다고 가정.
* 페이지에 대한 매핑이 필요.
* 프로그램 실행 시, 각 명령어의 반입 시 메모리가 두 번 참조.(명령어 위치 파악하기 위해 테이블 접근, 다음 배열 자체 접근하기 위해)

<img src="image\image09.png" width="300" height="300"/>

* 가장 아래 그래프가 명령어 메모리 참조.
* 중앙 그래프는 배열에 대한 접근.
* 맨 위의 그래프는 페이지 테이블 접근.

## 21.6 요약
> 페이징은 메모리를 고정 크기로 나눔. 가상 주소 공간의 드문 사용을 허용
> 페이징 구현을 제대로 하지 못하면 컴퓨터가 매우 느려짐. 메모리 낭비 초래.