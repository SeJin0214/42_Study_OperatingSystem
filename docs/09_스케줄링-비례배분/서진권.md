# 스케줄링 비례 배분

>비례배분 반환 시간이나 응답 시간을 최적화 하는 대신 스케줄러가 각 작업에게 CPU의  
일정 비율을 보장 하는 것.  
비례 배분 스케줄링의 좋은 예시 : 추첨 스케줄링!

## 9.1 기본 개념 : 추첨권이 당신의 지분이다.

추첨권은 프로세스들의 CPU점유율의 지분이다.  
예를들어 A 와 B 두개의 프로세스가 있다. A에게는 추첨권을 75장 B에게는 25장을 준다면  
A는 CPU를 75%할당 B는 25% 할당하는게 목적이다.  
> 첨스 스케줄링의 장점 ->무작위성  
>1. 전통적인 방식이 잘 해결하지 못하는 특이 상항을 잘 대응한다.  
>2. 무작위 추첨 방식은 매우 가볍다. > 관리해야 할 상태 정보가 거의 없기 때문이다.
>3. 매우 빠르다. 난수 발생 시간이 빠르기만 하면 결정 역시 빠르게 된다.

무작위성은 원하는 비율을 보장하지 않는다. 하지만 두 작업이 장시간 실행될수록  
원하는 비율을 가지게 된다. > 동전 던지기를 생각해 보자.  
동전던지기를 무한으로 하게 된다면, 결국 앞뒤가 나오는 비율이 5:5가 된다.  
짧은 시간동안 작업이 실행이 되면 우리가 원하는 비율은 나오지 않지만, 장기간이  
되면 우리가 원하는 비율을 가질 수 있다.  

## 9.2 추첨 기법

### 추첨권 화폐

사용자가 추첨권을 자신의 화폐가치로 추첨구너을 자유롭게 할당할 수 있도록 허용한다.  
예를 들면 A, B에게 각각 100장의 추첨권 을 할당  
A는 A1과 A2에게 100장을 500장으로 쪼개서(자신만의 비율로 만들어서) 다시 재할당  
B는 100장을 10장으로 병합해서 재할당  
시스템은 화폐를 다시 비율 조정해서 추첨권의 총량의 비율을 기준으로 추첨 한다.

### 추첨권 양도

말그대로 추첨권을 양도하는 방식이다.  
프로세스는 일시적으로 자신의 추첨권을 다른 프로세스에게 넘겨줄 수 있다.  
클라이언트/ 서버 환경에서 유용  

### 추첨권 팽창

프로세스는 일시적으로 자신이 소유한 추첨권의 수를 늘리거나 줄일 수 있다.  
프로세스들이 서로 신뢰할 떄 유용하다.  
욕심많은 심술 꾸러기가 추첨권의 양을 혼자서 팽창시킬 수 있어 컴퓨터를 장악할 수 있다.  

## 9.3 구현

>구현이 단순하다.  
난수 발생기, 프로세들의 집합을 표현하는 자료구조, 추첨권의 전체 개수 뿐

```c
// counter: 당첨자를 발견했는지 추적하는 데 사용됨
int cnt = 0;

//winner : 0 부터 총 추첨권의 수 사이의 임의의 값을 얻기 위해 난수 발생기를 호출함
int winner = getrandom(0, totaltickets);

//current: 작업 목록을 탐색하는 데 사용
node_t *current = head;
while(current)
{
	cnt = cnt + current->tickets;
	if (counter > winner)
		break ;//당첨자 발견
	current = current->next;
}
// current는 당첨자를 가르킴: 당첨자가 실핼될 수 있도록 준비
```
> list 순회하면서 cnt 의값이 winner의 값을 초과할때까지 추첨권의 갯수를 더함  
값이 초과하게 되면 리스트의 현재 원소가 당첨자가 된다.

## 9.4 예제

추첨 스케줄링의 무작위성 때문에 한 작업이 다른 작업보다 먼저 종료될 수 있다.  
그래서 사용하는 것이 불공정 지표 -> U <- 
>U(unfairness metric)은 첫 번째 작업이 종료된 시간을 두 번째 작업이 종료된 시간으로  
나눈 값이다.  

그림 <9.2>에서 보다시피 작업 길이가 길지 않은 경우에 평균 불공정 정도는 심각하다.  
작업이 충분한 기간 동안 실행되어야 추첨 스케줄러는 원하는 결과에 가까워짐  

## 9.5 추첨권 배분 방식

추첨권을 배분하는 방법은 매우 어렵다.  
괜찮은 방식이 존재 하지만 좋은 방식은 뭘까?????   
추첨권도 랜덤으로 뿌려버린다면?? 또는 추첨권을 달라고 노력하는 프로세스에게 기회를 준다??  
더 좋은 방법은 뭘까?  

## 9.6 왜 결정론적 방법을 사용하지 않는가

결정론적 방법을 쓰지 않는 이유는 간단하다.  
압도적으로 추첨 스케줄링이 간단하고 쉽기 때문이다.  
* 프로세스의 상태를 유지 할 필요가 없다.
* 새 프로세스를 추가할때, 새로운 프로세스가 가잔 추첨권의 개수, 전체 추첨권의 개수만  
갱신하고 스케줄한다.  

## 9.7 리눅스 CFS(Completely Fair Scheduler)

* 장점 : 효율성, 확장성  
>효율성 최적의 내부 설계와 자료 구조 사용을 통해, 스케줄링 결정을 매우 신속히 수행  

### 기본 연산
CFS는 모든 프로세스들에게 CPU를 공평하게 배분하는 것을 목표호 한다.  
>virtual runtime 이라는 간단한 counting 기반테크닉을 사용한다.  
프로세스 실행 vruntime 값을 누적시킨다.  
각 프로세스의 vrutime은 실제 시간과 같은 속도로 증가한다.  
스케줄링시 CFS는 가장 낮은 cruntime을 가진 프로세스를 다음에 실행할 프로세스로 선택.  

CFS가 자주실행 된면 공정정이 좋아짐, 하지만 많은 문맥 교환이 발생해서 전체 시스템 성능에  
악영향을 미칠 수 있음.  
드물게 실행되면 반대로 성능은 향상되지만 공정성은 약화된다.  

문제를 해결하기 위해 다양한 변수를 사용한다.  
* sched_latency : 여러 프로세스가 cpu를 번가아서 사용하는 상황에서 하나의 프로세스가 cpu를 사용한 후,  
다음번에 CPU를 사용할 수 있을 때까지의 최대 시간 간격을 나타냄.
* min_granularity : 타임 슬라이스 변수, CFS는 각 프로세스에게 할당된 시간 조각 이하 되지 안도록 하여  
스케줄링에 너무 많은 시간을 소비하지 않도록 한다.

### 가중치
CFS는 사용자나 관리자가 프로세스의 우선 순위를 조정하여 다른 프로세스들 더 보다 많은 CPU 시간을 할당받게  
할 수 있다. 티켓이 아닌 프로세스의 nice 레벨이라는 고전적 UNIX 메커니즘 사용.

### 기본 연산 Red-Black 트리의 활용

균형 트리의 한 종류, 실행중이거나 실행 가능한 프로세스들만 이 구조에 보관.  
프로세스가 sleep 상태가 되면, 프로세스는 트이에서 제거되고 다른곳에 보관  

### I/O와 잠자는 프로세스 다루기
기아현상을 방지하기 위해 CFS는 잠자는 프로세스가 깨어나게되면 CPU를 독점하지 못 하도록  vruntime을  
적절하게 재설정한다.  