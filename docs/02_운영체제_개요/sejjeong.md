<aside>
💡 프로그램이 실행될 때 어떤 일이 일어날까?

프로그램은 매우 단순한 일을 한다 : **명령어를 실행한다**. 

</aside>

폰 노이만 컴퓨터 모델

- cpu 명령어 사이클
    
    프로세서는 명령어를 초당 수백만 번 (요즘은 수십억 번) 반입(fetch) 하고, 해석(decode) 하고 (즉, 무슨 명령어인지 파악하고), 실행(execute)한다 
    
    (즉, 두 수를 더하고, 메모리에 접근하고, 조건을 검사하고, 함수로 분기하는 등의 정해진 일을 한다). 명령어 작업을 완료한 후 프로세서는 다음 명령어로, 또 그 다음 명령어로 프로그램이 완전히 종료될 때까지 실행을 계속한다.
    

### 이 책에서 무엇을 배우는가?

1. 시스템을 사용하기 쉽게하기 위해(easy to use) 프로그램 실행 시 다양한 일들이 발생한다는 것을 배울 것
2. 운영체제가 구현한 동시에 다수의 프로그램을 실행시키는 기본적인 기법(mechanism)에 대해 다룰 것 (자원 관리자로서의 역할)
3. 운영체제와 사용자가 상호작용 할 수 있게 만드는 API에 대해 논의한다.
4. 시스템을 편리하고 사용하기 쉽게 만드는 데 필요한 개념(abstraction)들을 정의

# 운영 체제가 어떤 일을 하는가?

1. CPU, 메모리, 디스크와 같은 물리 자원을 가상화(virtualize)
2. 병행성과 관련된 복잡한 문제를 처리
3. 파일을 영속적으로 저장하여 아주 오랜 시간 동안 안전한 상태에 있게 한다.

1. 프로그램을 쉽게 실행(동시에 실행도 가능)
2. 프로그램 간의 메모리 공유
3. 장치와 상호작용

# 운영체제 중요 포인트

## 가상화(virtualization)

1. 물리적 자원(메모리, 디스크)를 이용하여 가상 형태의 자원을 생성한다. 
2. 사용자에게 API를 제공한다. (시스템 콜)
    1. 메모리 할당
    2. 파일 접근
    3. 프로그램 실행 등
3. CPU 공유
    - 많은 프로그램들이 CPU를 공유하여 동시에 실행되게 한다.
    - 프로그램들이 디스크 등의 장치를 공유한다.
4. CPU 가상화
    - CPU가 매우 많은 수인 것처럼 보이는 방법
    - 프로그램 동시에 실행 시키기(CPU 가상화 덕분에 가능하다)
5. 메모리 가상화
    - 물리 메모리 모델
        - 바이트 배열
        - 읽고(load) 쓰기(store) 위해, 데이터와 주소를 명시
        - 프로그램의 명령어 역시 메모리에 존재한다.
    - 물리 메모리를 다른 프로그램과 공유하는 것이 아니라 **프로세스마다 가상 주소 공간을 갖는다**.
    - 운영체제가 가상 주소 공간을 물리 메모리로 mapping한다.

<aside>
💡 가상화도 결국 시스템, 프로그램이다.

어떤 **기법**과 **정책**을 사용하여 **자원을 가상화**를 시키는가? **어떻게 효율적으로 구현**하는가? **어떤 하드웨어 지원**이 필요한가?

</aside>

## 병행성(concurrency)

프로그램이 동시에 실행하는 것 

1. 어셈블리로 내려가면 명령어가 원자성을 띄지 않음
2. 이 때문에 발생하는 문제가 많다. (레이스 컨디션 등)

<aside>
💡 병행 프로그램이 올바르게 동작하려면 어떻게 해야 하는가?

</aside>

## 영속성(persistence)

- **DRAM** 같은 휘발성 저장 방식으로는 **데이터를 영속적으로 저장할 수 없다**.
- HDD와 SSD를 사용해야 하는데, 이를 관리하는 소프트웨어를 **파일 시스템**이라 부른다.

<aside>
💡 데이터를 영속적으로 저장하는 방법은 무엇인가??

</aside>

- 파일 시스템 역할
    - 새 데이터가 디스크의 어디에 저장될지 결정
    - 파일 시스템이 관리하는 다양한 자료 구조를 통하여 데이터의 상태를 추적
    - 효율적인 디스크 작업을 위해 단순 리스트에서 복잡한 B-트리까지 다양한 종류의 자료 구조를 사용

## 인터페이스

프로그램을 실행하고, 멈추고, 어떤 프로그램을 실행시킬 것인가를 운영체제에게
알려줘야 한다.

OS가 제공하는 API를 이용해야 한다. 

# 설계 목표

- 설계와 구현에 중요한 목표는 성능이다. 다른 말로 표현하면 **오버헤드를
최소화(minimize the overhead)하는 것**
- 응용 프로그램 간의 보호, 그리고 운영체제와 응용 프로그램 간의 보호
    - 프로세스를 다른 프로세스로부터 고립시켜야 한다.
- 계속 실행 되어야 한다.

## 개인적으로 저장해 놓을 것

컴퓨터 과학에서 추상화는 모든 일에 근간이다.
추상화를 통해 큰 프로그램을 이해하기 쉬운 작은 부분들로 나누어 구현할 수 있다.
어셈블리 코드를 몰라도 C와 같은 고수준 언어로 큰 프로그램을 작성하는 것이 가
능하다. 추상화는 논리 게이트를 고려하지 않고도 어셈블리 코드를 작성할 수 있게 하며, 트랜지스터에 대한 지식없이 게이트를 이용하여 프로세서를 만들 수 있게 한다.
추상화는 너무 근본이기 때문에 중요성을 쉽게 잊을 수 있다. 이 강의를 진행하는 동안은
잊지 않도록 하자

- 실습 cpu 가상화 관련
    
    ```c
    // cpu.c
    #include <stdio.h>
    #include <stdlib.h>
    #include <sys/time.h>
    #include <assert.h>
    #include“common.h ”
    int main(int argc, char *argv[])
    {
    		if (argc != 2) {
    		fprintf(stderr, “usage: cpu <string>\n ”);
    		exit(1);
    		}
    		char *str = argv[1];
    		while (1) {
    				Spin(1);
    				printf(“%s\n ”, str);
    		}
    		return 0;
    }
    
    ```
    
    ```
    prompt> ./cpu A & ; ./cpu B & ; ./cpu C & ; ./cpu D &
    ```
    
    누굴 먼저 실행할 지는 OS 정책에 달려 있다. 
    
- 실습 메모리 가상화 관련
    
    ```c
    // mem.c
    
    #include <unistd.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include“common.h ”
    int main(int argc, char *argv[])
    {
    		int *p = malloc(sizeof(int)); // a1
    		assert(p != NULL);
    		printf(“(%d) memory address of p: %08x\n ”,
    		getpid() , (unsigned) p); // a2
    		*p = 0; // a3
    		while (1) {
    				Spin(1);
    				*p = *p + 1;
    				printf(“(%d) p: %d\n ”, getpid() , *p); // a4
    		}
    		return 0;
    }
    
    // prompt> ./mem &; ./mem &
    
    ```