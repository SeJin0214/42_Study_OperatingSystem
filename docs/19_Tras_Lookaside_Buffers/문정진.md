# 페이징 : 더 빠른 변환(TLB)

* 페이징은 성능 저하를 가져올 수 있음.

* 매핑 정보를 저장하는 페이지 테이블의 경우 큰 메모리 공간이 요구.

* 가상 주소에서 물리 주소를 변환하기 위해서 해당 정보를 읽어야함.

* 페이지 테이블 접근 시 메모리 읽기는 성능 저하 유발.

* 해당 문제를 해결 위해 하드웨어 도움을 받음.

  >  **변환-색인 버퍼(translation-lookaside buffer), TLB**
  >
  >  1. 칩의 메모리 관리부의 일부. 자주 참조되는 가상 주소-실주소 변환 정보를 저장하는 하드웨어 캐시, **주소-변환 캐시(address-translation cache)**가 더 적합한 명칭.
  >  2. 가상 메모리 참조 시, 하드웨어는 먼저 TLB에 원하는 변환 정보 있는지 확인하고, 있다면 페이지 테이블을 통하지 않고 변환을 수행함. 해당 기능으로 페이징 성능을 향삳ㅇ시킴.

## 22.1 TLB의 알고리즘

```c
VPN = (VirtualAddress & VPN_MASK) >> SHIFT // 가상 페이지 번호 추출.
(Sucess, TlbEntry) = TLB_Lookup(VPN) // VPN의 TLB 존재 여부 검사.
if (Success == True) // 존재할 때, TLB 히트, TLB 변환 값이 있음.
	if (CanAccess(TlbEntry.ProtectBits) == True) // 페이지에 대한 접근 권함 검사 성공
		Offset = VirtualAddress & OFFSET_MASK
		PhysAddr = (TlbEntry.PFN << SHIFT) | Offset 
		AccessMemory(PhysAddr) // 정보를 원래 가상 주소의 오프셋과 합쳐 원하는 물리 주소 구성, 메모리 접근 가능.
	else
		RaiseException(PROTECTION_FAULT) 
eles // TLB 변환 정보 존재하지 않을 경우.
	PTEAddr = PTBR + (VPN * sizeof(PTE))
	PTE = AccessMemory(PTEAddr) // 하드웨어 변환 정보 찾기 위한 페이지 테이블 접근. 페이지 테이블 접근을 위한 메모리 참조.
	if (PTE.Valid == False) // 프로세스가 생성한 가상 메모리 참조가 유효, 접근 가능할 시
		RaiseException(SEGMENTATION_FAULT) 
	else if (CanAccess(PTE.ProtectBits) == False)
		RaiseException(PROTECTION_FAULT)
	else
		TLB_Inssert(VPN, PTE.PFN, PTE.ProtectBits) // 변환 정보를 TLB로 읽는다.
		RetryInstrution()
```

* 위 코드는 주소 변환부가 단순한 **선형 페이지 테이블**(배열)과 **하드웨어로 관리되는 TLB**로 구성
* TLB는 프로세싱 코어와 가까운 곳 위치. 매우 빠른 하드웨어로 구성되어 주소 변환 작업이 어렵지 않음.
* 미스가 발생 할 때, 페이징 비용이 커짐. 페이지 테이블을 접근하여 변환 정보를 찾아야기 때문에, 메모리 참조가 추가됨.
* TLB 미스가 많이 발생할 수록 메모리 접근 횟수가 많이 발생하니, TLB 미스는 최대한 피해야함.

## 22.2 예제 :  배열 접근

<img src="image\image01.png" width="300" height="300"/>

* 배열의 첫 항목 a[0]은 VPN=06, 오프셋=04 에서 시작.
* TLB가 완전히 초기화 되어 있는 경우, **공간 지역성**으로 표기처럼 배열의 항목들이 서로 인접해 있는 경우 히트, 페이지의 첫 번째 항목 접근시 TLB 미스가 발생함.
* 해당 프로그램이 계속 루프 종료 후 배열을 사용한다면, 모든 주소 변환 정보가 TLB에 탑재 되어, 전부 TLB 히트를 얻음. 
* **시간 지역성** 으로 인해 TLB 히트율이 높아짐.
* **시간 지역성**이란 한 번 참조된 메모리 영역이 짧은 시간 내 재 참조되는 현상.

## 22.3 TLB 미스는 누가 처리할까?

* TLB 미스 처리는 하드웨어와 소프트웨어에서 담당.

* 하드웨어 엔지니어 -> 운영체제 개발자 특성 때문에 완전한 신뢰 못함. -> TLB 미스를 하드웨어가 처리하도록 설계. -> 하드웨어가 페이지 테이블에 대한 명확한 정보를 가져야함.

* **CISC(comlpex-instruction set computers)**

  * 미스 발생 시 하드웨어가 하는 일.

    1. 페이지 테이블에서 원하는 페이지 테이블 엔트리 찾기
    2. 필요한 변환 정보 추출
    3. TLB를 갱신 후, 
    4. TLB 미스가 발생한 명령어 재실행.

    * ex) 인텔 x86 CPU가 하드웨어로 관리하는 TLB 대표적 예. **멀티 레벨 페이지 테이블** 사용


```c
VPN = (VirtualAddress & VPN_MASK) >> SHIFT
(Success, TlbEntry) = TLB_Lookup(VPN)
if (Success == True)
  if (CanAccess(TlbEntry . ProtectBits) == True)
    Offset = VirtualAddress & OFFSET_MASK
    PhysAddr = (TlbEntry . PFN << SHIFT) | Offset
    Register = AccessMemory(PhysAddr)
  else
    RaiseException(PROTECTION_FAULT)
else
  RaiseException(TLB_MISS)
```

* **RISC(reduced instruction set computin)**
  * CISC보다 최근에 등장한 컴퓨터 구조.
  * RISC 기반 컴퓨터는 **소프트웨어 관리 TLB**를 사용
    * RISC 기반 컴퓨터 TLB 미스 처리 관리 과정.
      1. TLB 주소 실패 시, 하드웨어는 예외 시그널 발생.
      2. 예외 시그널 받은 운영체제는 명령어 실행을 잠정 중지.
      3. 실행 모드를 커널 모드로 변경해 커널 코드 실행 준비, 커널 주소 공간 접근 할 수 있도록 **특권 레벨**로 상향 조절
      4. 커널 모드로 변경 되면 **트랩 핸들러** 실행, 트랩 핸들러는 TLB 미스 처리 담당하는 운영체제 코드.
      5. 트랩 핸들러는 페이지 테이블을 검색, 변환 정보 찾고 TLB 접근 가능한 특권 명령어 사용해 TLB 갱신 후 리턴.
      6. 트랩 핸들러에서 리턴되면 하드웨어가 명령어 재실행. TLB 히트가 됨.
    * TLB 미스 처리 트랩 핸들러와 시스템콜 트랩 핸들러 차이
      * 시스템 콜 호출 경우 -> 트랩 핸들러 리턴 후 시스템 콜을 호출한 명령어의 다름 명령어 실행.
      * TLB 미스 처리 경우 트랩 리턴하면 트랩을 발생하면서 명령어를 다시 실행해야하며, 재실행 시 TLB에서 히트 발생. 트랩 발생하면 운영체제는 트랩 핸들러 종료되었을 때 다시 실행을 계속할 명령어 주소를 저장.
    * TLB 미스 핸들러 실행 시, TLB 미스가 무한 반복되지 않게 주의.
      * TLB 미스 핸들러를 물리 메모리에 위치 -> TLB 미스 핸들러는 unmap되어 주소 변환이 필요 없음.
      * TLB의 일부를 핸들러 코드 주소로 저장해 영구히 할당. TLB 핸들러는 항상 TLB 히트되며 이를 연결(wired) 변환이라함.

## 22.4 TLB의 구성 : 무엇이 있나?

> 하드웨어 TLB 구성 : 
>
> * 32, 64, 128개의 엔트리를 가지며, **완전 연관** 방식으로 설계됨.
> * 완전 연관 방식에서 변환 정보는 TLB내에 어디든 위치할 수 있으며, 검색은 병렬적으로 수행됨.
> * 변환 정보 저장 위치는 제약이 없으며, 항목마다 VPN, PFN 있음.
> * TLB는 일반적으로 valid bit를 갖고 있음. 해당 비트는 특정 항목이 유효한 변환 정보 갖고 있는지 여부를 나타냄.
> * 주소 공간 식별자(address-space identifier), 더티 비트(dirty bit) 있음.

## 22.5  TLB의 문제 : 문맥 교환

* TLB 사용 시, 프로세스 문맥 교환 시, 새로운 문제 발생.
* TLB에 있는 가상 주소와 실제 주소 간의 변환 정보는 탑재 시킨 프로세스에만 유효.
* 새로운 프로세스가 이전 프로세스의 변환 정보를 사용하지 않게 해야함.
* 프로세스1, 프로세스2 의 VPN10번에 대한 변환 정보가 두 개 존재할 때, 어떤 프로세스가 정확히 어떤 물리 프레임을 가지는지 모름. -> TLB 정확하고 효율적인 멀티 프로세스 간의 가상화 지원을 위한 추가적인 기능이 필요.
  * 해결 방안
    * 문맥 교환 수행 시, 다음 프로세스가 실행 되기 전 기존 TLB 내용 비우기.(하드웨어 관리된 TLB는 페이지 테이블 베이스 레이즈터가 변경 될 때 비우기 가능.)
      * 단점 : 새로운 프로세스 실행 될때마다 데이터와 코드 페이지에 대한 접근으로 TLB 미스 발생. -> 문맥 교환 빈번할 시 성능 저하.
      * 개선 : 문맥 교환이 일어나더라도 TLB 내용을 보존하는 기능 추가.
        * TLB내 주소 공간 식별자(address space identifier, ASID) 필드 추가
        * 주소 공간 식별자 사용시, 프로세스 별로 TLB 변환 정보 구분 가능.

## 22.6 이슈 : 교체 정책

* TLB 캐시 교체 정책 중요.
* 디스크와 메모리 간의 페이지 스와핑 부분에서 상세히 다룸
  * 최저 사용 빈도(least-recently-used, LRU) : 
    * LRU는 메모리 참조 패턴에서의 지역성 최대한 활용.
    * 사용되지 않은지 오래된 항목일수록, 앞으로 사용 가능성 적음.
  * 랜덤(random) 정책: 교체 대상 무작위.

## 22.7 실제 TLB

<img src="image\image02.png" width="300" height="300"/>

* TLB가 어떻게 생겼는지, MIPS R4000.
* MIPS = 32비트 주소 공간에 4KB 페이지 지원.
* VPN = 19비트, PEN = 24비트, 오프셋 = 12비트.
* 전역(global)비트 G. -> 프로세스들 간 공유되는 페이지들 위해 사용. 전역 비트 있을 시 ASID 무시.
* ASID 8비트 길이의 필드. 3비트 길이는 일관성(coherence, C)비트.
* 더티(dity)비트는 페이지 갱신 시 세팅.
* 유효(valid)비트는 항목에 유효한 변환 정보 존재 나타냄.
* 페이지 마스크는 표현되어 있지 않음. -> 여러 개의 페이지 크기 지원시 사용.

## 22.8 요약

* TLB를 주소 변환 캐시로 사용해 메모리의 참조들은 메인 메모리 상의 페이지 테이블을 읽지 않고도 처리가 가능.
* TLB 사용으로 일반적인 경우 프로그램은 메모리 가상화 기능이 없는 것과 동일하느 성능을 보임.
* TLB는 페이징 사용의 필수 요소.
* 프로그램 접근 시간동안 페이지의 수가 TLB에 들어가는 수보다 많다면 TLB 미스 발생, 동작이 느려짐. -> TLB 범위 벗어남.
* 더 큰 페이지들 지원 위헤서 데이터베이스 관리 시스템같은 프로그램 사용. 자료구조가 크며 임의적으로 접근.
* TLB는 CPU 파이프 라인에서 TLB 접근은 병목이 발생. 물리적으로 인덱스된 캐시 사용시 문제가 됨.
* 가상적으로 인덱스된 캐시로 일부 성능 문제 해결.