# 빈 공간 관리
> 메모리 관리 시스템 : 프로세스 힙의 페이지 관리 malloc 라이브일 수도 있거나, 프로세스의 주소 공간의 일부 관리하는 운영체제 자체일수도 있음.  

빈 공간 관리 - 관리하는 공간이 가변-크기 빈 공간들의 집합으로 구성되어 있는 경우, 관리가 더 어려움. 빈 공간들이 다양한 크기의 작은 조각으로 분할 되어 단편화가 발생.  빈 공간들의 전체 크기가 크더라도, 연속된 영역이 존재하지 않으면 요청은 실패.  

단편화의 예시  
<img src="image\img01.png">

## 20.1 가정

사용자 수준 메모리 할당 라이브리 초점에 맞춘 역사.  
* malloc & free
    * void *malloc(size_t size)는 응용 프로그램이 요청한 바이트 수를 나타내는 변수 size를 받아들림. 요청된 크기와 같거나 큰 영역을 가르키는 void 포인터를 반환.
    * void free(void *ptr) 포인터 인자를 전달 받아 해당 영역을 해체, 해체 크기 정보는 전달하지 않음.
    * 라이브러리가 관리하는 공간을 힙(heap)으로 불름.
    * 힙의 빈 공간 관리를 일반적으로 링크드리스트 사용.
* 내부 단편화 : 할당기가 요청한 크기보다 더 큰 메모리 청크를 할당 할 경우, 요청되지 공간에 대해 할당 청크 내부에서 낭비가 일어났기 때문.

## 20.2 저수준 기법들
1. 분할(splitting)과 병합(coalescing)
<img src="image\img01.png">
빈 공간 리스트에 힙에 있는 빈 공간들의 집합.  
30바이트의 힙  
<img src="image\img02.png">
힙의 빈 공간 리스트에는 2개의 원소가 있음.  
첫 번째 10바이트 빈 세그멘트, 뒤에 나머지 빈 세그멘트.  
- 10바이트를 초과하는 모든 요청은 실패로 NULL 반환.  
- 요청한 크기의 메모리 청크가 없기 때문에.  
- 10바이트보다 적은 요청의 경우는?  
_ 분할(splitting) 작업 수행.  
- 요청에 만족하는 빈 청크 찾아 두 개로 분할  
- 첫 번째 청크 호출자에게 반환, 두 번째 청크 리스트에 남음.
- 1바이트 요청 후 결과 이미지
<img src="image\img03.png">
- 기본적인 리스트 모습은 변하지 않음.  
- 

2. 할당된 영역의 크기 파악.
* free(void *ptr)은 크기를 매개변수로 받지 않음. 인자를 전달 받으면 해제되고 메모리 크기 신속히 파악해 그 공간을 빈 공간 리스트에 추가를 가정.
- 할당기는 추가 정보를 헤더 블럭에 저장.
- 헤더 블럭은 메모리에 유지되며 해제된 청크 바로 직전 위치.

<img src="image\img04.png">

```c
int main()
{
ptr = malloc(20);
//malloc을 호출하고 결과를 ptr에 저장
}
```

```c
typedef struct __header_t
{
    int size;
    int magic;
} header_t;
```

<img src="image\img05.png">

```c
void free(void *ptr)
{
    header_t *hptr = (void *)ptr - sizeof(header_t);
}
```
* 헤더를 가리키는 포인터 얻어 내면, 라이브러리 매직 넘버 기대 값과 일치 비교해 안정성 검사 실시.
* 새로 해제된 영역의 크기를 계산.
* 주의사항 : 사용자가 N바이트의 메모리 청크 요청하면, 라이브러리는 크기 N의 빈 청크를 찾는 게 아닌, 빈 청크의 크기 N 더하기 헤더의 크기인 청크를 탐색.

3. 빈 공간 리스트 내장
* 빈 공간 리스트를 어떻게 구현할까?
* 새로운 노드를 위한 공간 필요시 malloc 호출하지만 메모리 할당 라이브러리 루틴에선 불가능
* 빈 공간 내에 리스트를 구축해야함.
* 힙의 크기가 4KB를 빈 공간 리스트로 관리하기 위해서 리스트를 초기화해야함.

```c
typedef struct __node_t
{
    int size;
    struct __node_t *next;
} node_t;
```

* 힙을 초기화하고 힙에 빈 공간 리스트의 첫 번째 원소 넣는 코드

```c
node_t *head = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE, -1, 0);
head->size = 4069 - sizeof(node_t);
head->next = NULL;
```

* 코드 실행 후 리스트는 크기 4088의 항목 하나만 가짐.
* head 포인터는 시작 주소를 담고 있으며, 시작 주소 16kb 가정.
* 해당 힙모양
<img src="image\img06.png">

* 100바이트 메모리 청크 요청.
* 라이브러리 해당 크기의 청크 찾기.
* size 4088 청크 선택
* 빈 영역 크기 + 헤더의 크기 충족 가능한 청크와 나머지 빈 청크 두 개로 분할
* 헤더의 크기를 8바이트로 가정시 해당 아래 이미지와 비슷.

<img src="image\img07.png">

* 100바이트 요청시 기존 하나의 빈 청크 중 108바이트 할당 후 할당 영역 가리키는 포인터 반환
* free에 사용할 8바이트 공간에 헤더 정보 넣기.

* 100바이트씩 할당된 3개의 공간 존재하는 힙.

<img src="image\img08.png">

* free를 호출해 할당 영역 중 가운데 청크 반환.
* 라이브러리 신속히 빈 공간 파악, 빈 청크에 빈 공간 리스트 삽입.

<img src="image\img09.png">

* 빈 공간 리스트의 첫 번째 원소 작은 빈 청크, 두 번째 큰 빈 청크.
* 단편화 발생.
* 해결책 : 리스트 순회하면서 인접한 청크 병합.

<img src="image\img10.png">

4. 힙의 확장
* 힙의 공간이 부족한 경우 NULL을 반환.
* 대부분의 할당기는 적은 크기의 힙으로 시작해 소진하면 운영체제로 부터 많은 메모리 요청.
* 확장 시키기 위해 특정 시스템 콜 호출
* 확장된 새로운 청크 할당
* sbrk 요청 수행을 위해 빈 물리 페이지 찾아 프로세서의 주소 공간 매핑.
* 새로운 힙의 주소 반환.

## 20.3 기본 전략
1. 최적 적합 (Best Fit)
    * 빈 공간 리스트 검색해 요청한 크기와 같은 더 큰 빈 메모리 청크 찾기
    * 후보 그룹 중 가장 작은 크기의 청크 반환
    * 해당 청크를 최적 청크이며 최소 적합이라고도 불림.
    * 빈 공간 리스트 순회하면서 반환할 정확한 블럭 찾기
    * 정교하지 않은 구현은 빈 블럭 찾기 위해 전체 검색하기 때문에 성능 저하.
2. 최악 적합 (Worst Fit)
    * 최적 적합의 반대 방식
    * 가장 큰 빈 청크 찾아 요청된 크기만큼 반환
    * 남는 부분은 빈 공간 리스트 유지
    * 수 많은 적은 청크 대신 커다란 빈 청크 남김.
    * 전체 탐색하기에 비용 높으며, 엄청난 단편화와 오버헤드가 많음.
3. 최소 적합 (First Fit)
    * 최소 적합보다 간단하게 요청보다 큰 첫 번째 블럭 찾아 요청 후 반환
    * 남은 빈 공간은 후속 요청 위해 계속 유지.
    * 속도가 빠름.
    * 블럭을 찾기 위해 빈 공간 전체 탐색 하지 않아도 됨.
    * 리스트의 시작에 크기가 작은 객체가 많이 생김.
    * 할당기 빈 공간 리스트 순서 관리가 주요 쟁점.
    * 주소-기반 정렬 사용하여 병합을 쉽게, 단변화 감소
4. 다음 적합 (Next Fit)
    * 마지막으로 찾았던 원소 가리키는 추가의 포인터 유지.
    * 빈 공간 탐색을 리스트 전체 균등하게 분산.
    * 리스트의 첫 부분 단편이 집중적으로 발생을 방지.

## 20.4 다른 접근법
1. 개별 리스트(segregated list)
    * 특정 응용 프로그램 한두 개 자주 요청하는 크기 있다면, 해당 객체를 관리하기 위한 별도 리스트 유지.
    * 특정 크기의 요청을 위한 메모리 청크 유지함으로 단편화 가능성 줄임.
    * 지정된 크기의 메모리 풀과 일반적인 풀에 얼마만큼의 메모리 할당해야하는지 문제 야기
    * 슬랩 할당기 (slab allocator)
        * 커널이 부팅될 때 커널 객체를 위한 여러 객체 캐시 할당.
        * 커널 객체란 파일 시스템 아이노드 등 자주 요청되는 자료 고조
        * 객체 캐시는 지정된 크기의 객체들로 구성된 빈 공간 리스트.
        * 기존 할당된 캐시 공간이 부족하면 상위 메모리 할당기에 추가 슬랩 요청
        * 요청의 전체 크기는 페이지 크기의 정수배.
        * 슬랩 할당은 빈 객체들 사전에 초기화 된 상태로 유지된점에서 개별 리스트방식보다 우수
        * 자료구조 초기화와 반납에 많은 시간 소요.
2. 버디 할당
    * 이진 버디 할당기
        * 빈 메모리는 처음 개념적으로 크기 2N인 하나의 큰 공간으로 생각됨
        * 메모리 요청 발생, 요청 충족시키기 충분한 공간 발견될 때까지 빈 공간을 2개로 계속 분할.
        * 2의 거듭재곱 크기 만큼 블럭 할당 할 수 있어 내부 단편화로 고생할 수 있음
        * 해제시 비어있는 두 블럭을 병합함, 해당 병합이 되었고 또 다른 블럭이 있다면 다시 합병함. 재귀 방식으로 빈 공간을 복원

## 20.5 요약
할당기는 많은 곳에 존재. 해당 시스템을 구축하는데 많은 선택 사항이 있고, 빠르고 효율적이고 확장성 좋은 할당기 만드는 일이 현대 컴퓨터의 숙제.