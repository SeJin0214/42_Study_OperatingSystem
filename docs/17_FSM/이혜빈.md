# 20 빈 공간 관리

가변-크기 빈 공간(동적할당)들의 집합으로 구성된 빈 공간의경우 관리가 더 어렵다.  
malloc()과 free(), 세그멘테이션으로 물리 메모리를 관리하는 경우 외부 단변화가 발생한다.  

<img src="image\img01.png">
이와 같은 경우 10바이트짜리 빈 공간 두 개로 빈 공간은 전체 20바이트지만, 15바이트의 메모리 요청은 실패한다.  
그렇다면 이 문제를 어떻게 해결해야 할까??

## 20.1 가정

	void *malloc (size_t size)
의 리턴값은 요청된 크기(size)만틈의 영역을 가리키는 void포인터를 반환한다.  

	free(void *ptr)
은 포인터를 인자로 받고 해당 영역을 해제한다. 이 때 free()는 해제하는 영역의 크기 정보를 전달하지 않는다는 것을 주목하자.

외부 단편화 방지에 방점을 두고,
클라이언트에게 할당된 메모리는 다른 위치로 재배치 될 수 없다고 가정한다.

## 20.2 저수준 기법들

### 일반적인 기법 : 분할과 병합  
---
#### 분할
빈 공간 리스트는 힙에 있는 빈 공간들의 집합이다.
<img src="image/img02.png">
사진과 같이 이 리스트는 10바이트 크기의 두 개의 빈공간을 가지고 있다.  
여기서 1바이트에 대한 메모리 요청이 들어온다면 분할 작업이 수행된다.  

메모리를 할당할 수 있는 빈 청크를 찾아 둘로 분할한 뒤, 첫 번째 청크는 호출자에게 반환하고, 두번쨰 청크는 리스트에 남아 두 번째 청크에 메모리 할당이 이루어지고 다음과 같은 모습이 된다.  

<img src="image/img03.png">

---

#### 병합

중간에 할당 되어있던 영역이 free되고 빈 영역이 리스트에 추가된다면 빈 공간 리스트는 다음과 같은 모습이 될 것이다.

<img src="image/img02_2.png">

이 경우 10바이트로 모든 청크가 쪼개져 있어 크기가 10이 넘는 메모리 요청은 할당되지 못할 것이다.  
이 문제를 해결하기 위해 할당기는 메모리가 반환(해제)될 경우 해제되는 청크의 주소와 인접한 빈 청크의 주소를 살펴보고 두 주소가 인접해 있다면 그들을 하나의 빈 청크로 병합한다.

---

### 할당된 공간 크기 파악
free가 크기를 매개변수로 받지 않는다면 어떻게 해제할 메모리 영역의 크기를 파악할까?  
할당기는 메모리 크기와 같은 추가정보를 헤더블럭에 저장하고 헤더 블럭은 할당되는 메모리 바로 위쪽에 위치한다.  

헤더에는 할당된 공간의 크기와 부가적인 정보(매직넘버)등이 저장된다.  
헤더에 저장된 정보를 통해 간단한 수학계산으로 해제된 영역의 크기를 계산할 수 있다.


### 빈 공간 리스트 내장

빈 공간 리스트를 만들기 위해 리스트를 할당하려면 어떻게 해야 할까?

우리는 새로운 노드를 할당할 때 malloc을 사용하지만, malloc메모리 할당 함수를 위한 리스트 생성에서는 malloc을 사용할 수 없다.  
(당연함. malloc만드는데 malloc을 이용해서 만들 수는 없음. 스파게티를 만들기 위해서 준비해야 하는 재료가 스파게티가 아니듯이)

대신 빈 공간 내에 리스트를 구축해야 한다.  
먼저 시스템 골 mmap()를 호출하여 영역을 구축한다.(이 때 head 포인터는 시작 주소를 담고 있따.)  
-> 메모리 할당(100바이트) 요청이 오면 충분한 크기의 빈 청크를 찾고 두 개로 분할한다.  
-> 요청한 100바이트 + free를 위한 헤더(8바이트) 총 108바이트를 할당 
-> 헤더공간의 next에는 다음 빈 공간 리스트의 주소를 적는다.  

이렇게 메모리가 할당되면 메모리의 할당 요청이 들어올 때 할당기는 신속하게 빈 공간의 크기를 파악하고 삽입하면 된다.  
해제 요청이 들어올 경우에는 단편화를 막기 위해 리스트를 순회하며 인접한 청크를 병합한다. 그런데 어떤 방법으로?

---

#### 힙의 확장(병합)

if 힙 공간이 부족하면?  그냥 실패 반환하면 됨.  
	고민 ㄴㄴ

이런 방법도 있고, 일반적으로는 시작은 달콤하게 평범하게 작은 크기의 힙으로 시작한 뒤, 모든 영역을 소진하면 시스템 콜 (sbrk)을 통해 확장된 영역에서 새로운 청크를 할당한다.

그럼 공간 새로 생겨서 할당할 수 있다! 야호!

---

## 20.3 기본 전략

이상적인 할당기의 조건  
속도는 빠르게, 단편화는 최소한.

1. 최적 적합.  
	요청한 크기 이상의 청크를 찾고 그 중 가장 작은 크기의 청크 반환  
	장점 : 리스트를 한 번만 순회 함, 공간의 낭비를 줄임  
	단점 : 항상 전체를 탐색하여 성능 저하 초래(비용 비쌈).

2. 최악 적합  
	최적 적합의 반대. 가장 큰 크기의 빈 청크 반환. 수많은 작은 청크 대신 커다란 빈 청크를 남기려고 시도.  
	단점 : 항상 전체를 탐색하여 성능 저하 초래(비용 비쌈).  
		  대부분 엄청난 단편화 발생

3. 최초 적합  
	간단함. 요청보다 큰 첫번째 블럭을 찾아서 반환.  
	장점 : 속도 빠름  
	단점 : 리스트의 시작에 단편화가 많이 발생할 수 있음  
	단점 보완 : 주소-기반 정렬을 사용하여 단편화 감소 가능   

4. 다음 적합  
	리스트의 처음부터 탐색하는 대신 마지막으로 찾았던 원소를 가리키는 포인터 유지. 단편화가 리스트 전체에 균등하게 분산됨.  
	최초 적합화 비슷한 성능.

---

## 20.4 다른 접근법

1. 개별 리스트 사용
	자주 요청되는 크기를 위해 자주 요청되는 크기 만큼의 리스트를 별도로 유지.  
	장점 : 리스트 탐색이 없으므로 할당과 해제를 신속하게 가능  
	단점 : 자주 요청되는 크기가 얼마인지를 알아야 함  
	단점 보완 : 슬랩 할당기를 통해 자주 요청되는 자료구조를 알아냄

2. 버디 할당  
	이진 버디 할당기. 2의 배수로 메모리가 초기에 할당된다. 메모리 요청이 발생하면 빈 공간을 할당할 수 있는 최소한의 크기로 빈 공간을 계속 쪼갬.  
	장점 : 해제될 떄 해제되는 크기(ex 8바이트)와 같은크기의 청크가 있는지 확인하고 있다면 재귀를 통해 병합함.  이게 되는 이유는 이진법으로 쪼개서 8은 8하나만 더 있기 때문.


