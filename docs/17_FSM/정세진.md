malloc을 만든다면 이 장을 참고하자 

## 메모리 관리 시스템

- 빈 공간 관리에 대해 논의
    - 고정 크기 단위의 리스트 유지
        - 매우 쉬움
    - 가변 크기 공간 집합
        - 세그멘테이션으로 관리하는 운영체제에서 발생
    - 둘 다 외부 단편화는 발생한다.

> 빈 공간 관리는 어떻게 해야 하는가?
> 
> 
> **시간과 공간의 오버헤드를 줄이는 방향**으로 
> 

### 가정

malloc은 size를 받아 요청된 크기만큼의 영역을 가리키는 주소를 반환

free는 인자로 받은 포인터의 영역을 해제한다. 해제할 땐 size를 받지 않는데, 크기를 어떻게 파악했는가? 

힙을 관리할 땐, 일반적인 링크드 리스트를 사용한다. (꼭 링크드 리스트일 필요는 없음) 

> 외부 단편화를 어떻게 방지하는 지에 대한 초점을 둔다.
> 
> 
> 물론, 내부 단편화도 발생할 수 있다. 
> 
> 클라이언트에게 할당된 메모리는 다른 위치로 재배치될 수 없다고 가정
> 
> → 이 경우 빈 공간 압축으로 단편화 제거는 못한다.
> 

### 저수준 기법

1. splitting(분할), coalescing(병합)
    - 30바이트의 힙에 10바이트의 빈 공간 리스트가 3개 있다고 가정
    - 10바이트를 초과한 요청은 NULL 반환 (메모리 청크가 없음)
    - 10바이트 보다 적은 경우는?
        - splitting(분할) 작업 수행
        - 만족하는 빈 청크를 찾아서 둘로 자른다.
        - 하나는 호출자에게 반환, 하나는 리스트에 남는다.
    - 10바이트 보다 큰 경우는?
        - coalescing(병합) 작업 수행
        - 빈 공간들을 병합, 해제되는 청크의 주소와 인접한 청크의 주소를 살펴본다.
        - 해제된 공간이 빈 청크와 인접해 있다면 병합한다.
2. 할당된 영역의 크기를 빠르고 상대적으로 쉽게 파악할 수 있는 방법
3. 빈 공간과 사용 중인 공간을 추적하기 위한 빈 공간 내에 간단한 리스트 구현

free는 헤더 블럭에 추가 정보를 저장한다. 보통 해제된 청크 바로 직전에 위치

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/458b7604-6670-43be-ab36-f842f03c3259/dccd6bf4-e5f1-4964-95b8-81c241cd07be/image.png)

메모리 할당 = 헤더 구조체 + 할당할 크기 

free 할 땐, 안에 매직 넘버를 비교하여 안정성 검사를 한다.

- 빈 공간 리스트 내장, 어떻게 구현할 수 있는가?
    
    힙의 크기를 4096 byte라 가정
    
    헤더 구조체 8byte라 가정
    
    flow
    
    1. malloc 호출
    2. 리스트 초기화 하나의 리스트를 갖고 있음
        1. 힙의 크기 - 헤더 크기 = 4088 길이의 항목을 갖고 있음 
    3. 100byte 요청 받음
        1. 청크를 찾는다.
        2. 4088 크기가 선택
        3. 요청 받은 크기(100) + 헤더 크기(8)와 나머지(3980)로 분할 한다.
    4. 100바이트 2개를 더 요청한다.
        1. 분할 하고 나면 324를 사용할 것이고 3764가 남는다.
    5. free를 해본다. free(16500)
        1. 리스트는 가상 주소 16KB에서 시작하므로 16384에서 시작한다.
        2. 116은 두번째 리스트 위치,  첫번째 리스트 크기(108) + 두번째 리스트 헤더(8)
    6. 단편화 발생
    7. 다 해제하면 모두 단편화가 될 것
    8. 리스트를 순회하여 인접한 청크를 병합해야 한다.
- 힙의 확장
    
    힙이 부족할 경우??
    
    당연하게도 실패를 반환(NULL)
    
    sbrk를 호출하여 힙을 확장하기도 함
    

### 기본 전략 (빈 공간 할당을 위한)

속도가 빠르고, 단편화가 최소인 게 최고

할당과 해제는 무작위라 어떤 기법을 사용해도 운이 좋지 않은 경우 성능이 매우 떨어짐

- 최적 적합 (Best Fit)
    1. 빈 공간 리스트를 검색
    2. 요청한 크기와 같거나 더 큰 빈 메모리를 찾음
    3. 요구사항에 맞으면서 가장 작은 메모리(최적 청크)를 반환
    
    단점 
    
    최적을 찾기 위해, 다 찾아봐야 할 수도 있다. 정교하게 구현하지 않으면 성능 저하 초래
    
- 최악 적합 (Worst Fit)
    
    가장 큰 빈 청크를 찾아 요청된 크기 만큼 반환하고 남은 것을 빈 공간 리스트에 유지한다.
    
    이것도 전체를 탐색 해야 하고, 엄청난 단편화와 오버헤드가 커서 좋지 않음
    
- 최초 적합 (First Fit)
    
    요청보다 큰 첫 번째 블럭을 찾아서 요청만큼 반환한다.
    
    - 장점
        - 속도가 빠르다.
    - 단점
        - 작은 단편화가 생기기 쉽다.
    
    주소-기반 정렬을 사용하여 병합을 쉽게하고 단편화를 감소 시킨다.
    
- 다음 적합 (Next Fit)
    
    마지막으로 찾았던 원소를 가리키는 추가의 포인터를 유지
    
    빈 공간 탐색을 리스트 전체에 더 균등하게 분산,
    
    리스트에 첫 부분에만 단편이 집중적으로 발생하는 것을 방지(계속 앞에서 잘라줄 테니 앞에 단편화가 집중 될 수 밖에 없다.)
    

### 다른 전략

- 개별 리스트
    
    특정 응용 프로그램이 한 두개 자주 요청하는 크기가 있다면, 그 크기의 객체를 관리하는 별도의 리스트를 유지한다.
    
    - 장점
        - 특정 크기의 요청을 위한 메모리 청크를 유지함으로써 단편화를 상당히 줄일 수 있다.
        - 요청된 크기의 청크만 존재하기 때문에 할당과 해제 요청을 신속하게 처리할 수 있다.
    
    문제
    
    - 별도의 리스트는 얼마만큼 크기를 잡아야 하는가?
    
    <aside>
    💡 해결 방안
    
    객체 캐시 : 지정된 크기의 객체들로 구성된 빈 공간 리스트, 메모리 할당 및 해제 요청을 빠르게 하기 위해 사용 → 아이노드만 있기도 하고, 락 구조만 담기도 함
    
    커널 객체 : 락, 파일 시스템 아이노드 등 자주 요청되는 자료구조
    
    </aside>
    
    - 슬랩 할당기
        - 커널이 부팅 될 때 커널 객체를 위한 여러 객체 캐시를 할당
        - 캐시 공간이 부족하면, 상위 메모리 할당기에 추가 슬랩을 요청
        - 요청 크기는 페이지 크기의 정수배
        - 요청된 페이지를 안 쓰면, 상위 메모리 할당기가 회수할 수 있음
    
    > 
    > 
    > 
    > Bonwick은 자료 구조의 초기화와 반납에는 많은 시간이 소요된다는 것을 발견하였다
    > 
- 버디 할당
    
    합병을 간단히 하는 방법 등이 설계 되었는데, 버디 할당이 이 중 하나
    
    해제 할 때 좋음
    
    flow
    
    1. 8 KB 블럭이 해제된다고 하자
    2. 비어있는 8 KB 다른 블럭이 비어 있는 지 확인
    3. 있다면 합병
    4. 비어있는 16 KB 블럭이 있는 지 확인
    5. 있다면 합병
    6. 재귀로 전체 빈 공간이 복원되거나 사용 중이 밝혀질 때까지 한다.

위의 아이디어들의 문제점

O(n) 방식이라 커질수록 검색이 느려짐

좀 더 정교한 것은 다른 자료구조를 사용하여 비용을 줄인다.

1. 균형 이진 트리
2. 스플레이 트리
3. 부분 정렬 트리