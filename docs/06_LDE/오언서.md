# 제한적 직접 실행 원리
cpu가상화 중 일어날 수 있는 문제점 <br>
1. 성능 저하
2. 제어 문제

## 9.1 기본 원리: 제한적 직접 실행(Limited Direct Execution)
프로그램을 cpu 상에서 직접 실행 <br>
<br>
운영체제　　　　　　　　　　　　　　　프로그램<br>
프로세스 목록의 항목 작성 <br>
프로그램 메모리 할당<br>
메모리에 프로그램 탑재<br>
argc/argv를 위한 스택 셋업 <br>
레지스터 내용 삭제 <br>
call main() 실행<br>
　　　　　　　　　　　　　　　　　　main() 실행 <br>
　　　　　　　　　　　　　　　　　　main에서 return 명령어 실행 <br>
프로세스 메모리 반환 <br>
프로세스 목록에서 항목 제거 <br>
<br>
## 9.2 문제점1: 제한된 연산
프로세스가 디스크 입출력 요청, 시스템 자원 추가할당 등 특수한 연산을 하길 원한다면? <br>
#### user mode
할 수 있는 일 제한
#### kernel mode
모든 작업 수행 가능<br>
#### system call
프로세스가 특권 명령어와 같은 제한 작업의 실행을 허용 <br>
ex) 파일 시스템 접근, 프로 세스 생성 및 제거, 다른 프로세스와의 통신 및 메모리 할당 등 <br>
#### trap
system call 을 실행하기 위해 프로그램이 실행해야하는 특수 명령어 <br>
커널 안으로 분기하는 동시에 특권 수준을 커널으로 상향 조정 <br>
return-from-trap 실행 시 사용자 프로세스로 제대로 리턴하기 위해 호출한 프로세스의 필요한 레지스터들을 저장해야 함<br>
#### return-from-trap
특권 수준을 다시 user mode로 하향 조정
#### LDE 프로토콜의 진행
- 전반부 커널: 트랩 테이블을 초기, CPU가 테이블의 위치 기억
- 후반부 커널: 
	1. return-from-trap를 이용하여 CPU를 사용자 모드로 전환 후 프로세스 실행
	2. 프로세스가 시스템 콜을 호출할 시 운영체제로 다시 트랩됨. 
	3. os가 시스템 콜 처리, return- from-trap 명령어를 사용하여 다시 제어를 프로세스에게 넘김. 
	4. 프로세스는 일을 다 수행한 후 main()에서 리턴. -> 일반적으로 스텁 코드로 리턴, 스텁 코드가 프로그램을 종료시킨다. 
	5. 종료시킬 때 exit() 시스템을 호출하고 다시 운영체제로 트랩됨. 이 시점에 os는 정리 작업을 함

## 9.3 프로세스 간 전환
#### 협조 방식
yield 시스템콜 호출 시 os에 제어를 넘겨 다른 프로세스 실행을 가능케 함. <br>
응용프로그램이 비정상적인 행위를 할 시 os에게 제어가 넘어감. <br>
#### 비협조 방식
협조 방식에서 무한루프에 빠졌을 때 컴퓨터를 재부팅하는 것이 좋은 방법. but 비협조 방식에서는 다른 해결책이 있다 !<br>
#### interrupt handler
타이머 장치가 밀리 초마다 인터럽트를 발생시키도록 함. 인터럽트가 발생 시 현재 수행 중인 프로세스는 중단, 미리 구성된 운영 체제의 인터럽트 핸들러가 실행됨. <br>
#### 문맥의 저장과 복원
스케쥴러: 현재 실행 중인 프로세스를 계속 실행할 잃인지 아니면 다른 프로세스로 전환할 잃인지를 결정<br>
다른 프로세스로의 전환이 결정되면 os는 문맥교환(context switch)라고 알려진 코드 실행.<br>
##### 문맥교환
1. os는 현재 실행 중인 프로세스의 레지스터 값을 커널 스택 같은 곳에 저장하고 곧 실행될 프로세스의 커널 스택으로부터 레지스터 값을 복원해야 함. 
2. return-from-trap 명령어가 마지막으로 실행될 때 현재 실행 중이던 프로세스로 리턴하지 않고 다른 프로세스로 리턴하여 실행을 재개할 수 있음. 
3. 어셈블리로 현재 실행 중인 프로세스의 범용 레지스터, PC, 현재 커널 스택 포인터를 저장한다. 
4. 곧 실행될 프로세스의 범용 레지스터, PC를 복원하고 커널 스택을 이 프로세스의 커널 스택으로 전환. 
5. 운영체제가 마지막으로 return- from-trap 명령어를 실행하면 곧 실행될 프로세스가 현재 실행 중인 프로세스가 되며 문맥 교환 종료
## 9.4 병행성이 걱정
system call을 처리하는 도중에 타이머 인터럽트가 발생하면? <br>
-> 인터럽트를 처리하는 동안 인터럽트 불능화