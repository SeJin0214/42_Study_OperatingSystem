# 6 제한적 직접 실행 원리

CPU 가상화를 위해서는 문제점이 뭘까?</br>
1. 성능 저하
2. OS가 원히지 않는 행동을 프로세스가 하는 경우

## 6.1 기본 원리 : 제한적 직접 실행

> 프로세스를 직접 CPU에서 실행시키는 것!</br>

문제점</br>
1. 프로세스가 OS가 원하지 않는 일을 할 수도 있는데 그건 어떻게 막아
2. 시분할 어떻게 만드냐?????

## 6.1 문제점 1: 제한된 연산

>사용자모드라는 상태를 만들어서 프로세스가 CPU에서 직접 실행되지만, 비정상적인 입력이 들어오면</br>
강제적으로 OS가 프로세스를 제거한다.</br>
!!!!!!하지만 사용자가 디스크 읽기와 같은 특권 명령어를 실행해야 한다면????</br>
프로세스가 사용자모드 -> 시스템콜 -> 커널로 분기 -> trap 명령어 사용(시스템콜 실행)</br>
-> 작업 끝나면 -> 모드를 사용자 모드로 하향 조정</br>

>trap 이란?</br>
매우 중요한 명령어 -> 시스템콜을 사용하기 위해서 trap 명령어를 사용해야 한다.</br>
커널은 부팅 시 트랩 테이블 만든다.</br>
시스템콜 사용 시 트랩 핸들러의 위치 알려줌</br>
예외적인 사건 발생 시(trap 명령어 호출) trap 핸들러 실행 콜번호가 유효하면 코드 실행</br>
trap 테이블 위치를 차지하는 것은 매우 강력한 파워를 가짐! 컴퓨터의 시스템을 장악할 수 있기 때문</br>

## 6.3 프로세스 간 전환

>협조 방식</br>
프로세스를 믿는 방식 -> 주기적으로 CPU의 통제권을 반납할 것이라고 믿는 방식이다. 하지만 프로그램을</br>
만드는 사람들은 그렇게 착한 사람들이 아니다. 최소한의 안전장치로 비정상적인 실행이 나오면 트랩 실행</br>
운영체제가 다시 주도권을 가진다.  

>비협조 방식 : 운영체제가 제어권 확보</br>
타이머 인터럽트를 이용하는 것. 예를 들어 10msec마다 타이머 인터럽트를 발생시키고, 인터럽트 핸들러를 실행</br>
인터럽트 핸들러는 운영체제의 일부분이므로 인터럽트를 처리하는 과정에서 운영체제가 CPU의 제어권을 가진다.</br>

>문맥의 저장과 복원</br>
운영체제가 제어권을 다시 획득하면 중요한 결정을 해야 함.</br>
현재 프로세스를 실행할 건지 아니면 다른 프로세스로 전환할 것인지.</br>
이건 운영체제의 스케줄러가 결정한다.</br>
다른 프로세스로 전환한다고 한다면???</br>
문맥 교환 코드 실행 </br> - 문맥 교환 코드란? : 현재 실행 중인 프로세스의 레지스터 값들을 커널 스택 같은 곳에 저장하고 새로이 실행될 프로세스의 커널 스택으로부터 레지스터값을 복원하는 것

## 6.4 병행실행으로 인한 문제

- 인터럽트 하는 과정에서 인터럽트가 발생한다면?
- 시스템 콜을 하는 과정에서 인터럽트가 발생한다면?

--> 병행성에 관한 내용 다음에 자세히 설명
- 
> 간략하게 알아보면</br>
인터럽트 불능화</br>
락 기법 등