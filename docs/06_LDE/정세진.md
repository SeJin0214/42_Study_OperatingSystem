CPU 가상화의 간단한 아이디어

→ CPU 시간을 나누어 쓴다.

아이디어의 문제

1. 성능 저하(오버헤드 줄이기)
2. 제어 문제(CPU가 운영체제 제어에서 벗어나면 안 된다)

<aside>
💡 제어를 잃지 않으면서도 어떻게 성능을 끌어올릴 수 있을까?

</aside>

# 제한적 직접 실행

프로그램을 CPU상에서 직접 실행하는 기법

운영체제가 프로그램을 실행하기 시작할 때 일어나는 일 

1. 프로세스 목록에 프로세스 항목을 만든다
2. 메모리를 할당한다.
3. 프로그램 코드를 메모리에 탑재하고 시작 코드로 점프한다.

## 문제점 1

문제

1. 이 프로그램이 운영체제가 원하지 않는 일을 하지 않는다고 어떻게 보장하는가?
    1. 제어권에서 벗어나기 때문에 이상한 행동을 하면 제재를 가하지 못한다.
2. 시분할을 어떻게 할 것인가?
3. 특수한 종류의 연산을 수행하고 싶으면 어떻게 해야 하는가? ex) 디스크 입출력, 추가 메모리 할당
    1. 프로세스는 특수한 연산의 권한이 없다.
    2. 권한을 주게 된다면, 모든 곳에 접근이 가능하기 때문에 문제를 일으킬 수 있어 막아야 한다.

프로그램에게 모든 자유를 준다면, 제어할 수 없게 된다. 

## 실행 모드

### 사용자 모드

이 모드에서 응용프로그램은 하드웨어 자원에 대한 접근 권한이 일부 제한되어 있다.

이 때 입출력 요청을 한 프로세스는 제거된다.

return-from-trap : 커널에서 되돌아오기

### 커널 모드

컴퓨터 모든 자원에 접근이 가능하다.

trap 명령어를 이용

## System call

<aside>
💡 사용자 프로세스가 디스크를 읽기와 같은 **권한 밖의 명령어를 실행해야 할 때**, **하드웨어가 제공해 주는 것**

</aside>

제공하는 System call 목록(간략)

1. 파일 시스템 접근
2. 프로세스 생성 및 제거
3. 다른 프로세스와의 통신
4. 메모리 할당
5. 및 수백개

**시스템 콜이 호출**되면 **사용자 모드에서** trap 명령어가 자동으로 호출하여 **커널 모드로 들어간다**.

**시스템 콜이 종료**되면 **커널 모드에서** return-from-trap 명령어를 호출하여 **사용자 모드로 들어간다**.

시스템 콜은 프로시저 콜과 형태가 똑같다. 내부에 trap만 호출하는 것일 뿐

1. 인자 전달(아마도 인자는 스택에 넣고 시스템 콜 번호는 특정 레지스터에 넣을 것이다)
2. 주소 저장
3. 점프
4. **trap 실행**
5. 코드 실행
6. 리턴 및 반환

> C 라이브러리에서 **시스템 콜을 호출하는 부분의 코드는 어셈블리어로 작성**된다
> 
> 
> system_call_number를 인자로 전달 받고, 인터럽트를 일으키는 int system_call_number 일 거 같다.
> 

main()에서 리턴할때, 일반적으로 스텁 코드로 리턴하고 **스텁 코드**가 프로그램을 종료시킨다.

## 트랩 테이블

<aside>
💡 하드웨어가 실행 중에 예외가 발생했을 때, 트랩 테이블을 이용하여 문제를 해결한다.

</aside>

1. 컴퓨터가 부팅할 땐 커널 모드에서 동작하여 하드웨어를 제어할 수 있다.
2. 부팅 때 운영체제가 예외와 맞는 트랩 테이블 을 초기화 한다. (CPU는 트랩 테이블 위치를 기억한다)
3. 예외가 발생하면 하드웨어가 해당 트랩 테이블 번호에 접근한다.
4. 어느 주소가 적혀있고, 점프한 곳이 **트랩 핸들러**다.

트랩 핸들러는 예외가 발생했을 때 행동하는 솔루션 같은 거다.

## 커널 스택

프로세스는 커널 모드로 진입할 때를 위해서 커널 스택을 각자 갖고 있다. PC나 여러 레지스터가 저장되고 복원되는 용도로 사용한다.

## 문제점 2 : 프로세스 간 전환

CPU 제어를 하고 있지 않은데, 어떻게 다른 프로세스로 전환할 수 있는가?

### 방법 1 : 시스템 콜 기다리기(협조)

yield(양도하다 라는 뜻으로 쓰이나?) system call

응용 프로그램이 비정상적인 작동(divide 0, memory crash 등)을 하면 트랩이 일어나 프로세스를 종료 시킬 수 있다. (이외에 딱히 할 게 없다)

무한루프라던가 악의적인 버그는 어떻게 할건데??

### 방법 2 : 운영체제가 전권 행사(비협조)

프로세스가 문제가 생기는 경우 하드웨어 도움 없이 운영체제는 할 수 있는 게 거의 없다. 

> 프로세스가 비협조적인 상황에서도 CPU의 제어를 획득하는 방법은 무엇인가?
> 

<aside>
💡 타이머 인터럽트!!!!!!!

</aside>

일정 시간이 인터럽트를 발생시켜 프로세스를 중단하고 운영체제에게 CPU 제어권을 넘긴다.

병행성 때 자세하게 말해준다. 

## 운영체제 스케줄러

운영체제가 CPU 제어권을 다시 획득했다면, 이전 프로그램을 다시 실행할 지, 다른 프로그램을 다시 실행할 지 결정해야 한다. 

<aside>
💡 이 때 중요한 것이 **스케줄러!!!**

</aside>

다른 프로그램이 실행된다면 **문맥 교환(context switch)**이 이루어진다.

1. 실행 중이던 프로세스 커널 스택에 레지스터 값 등을 저장
2. 실행할 프로세스 커널 스택에서 레지스터 값 등을 복원 (이때 프로세스 주소는 어디에 있는가? 프로세스 목록에 저장되었겠지?)
3. 실행할 프로세스로 리턴 

중요한 것은 프로세스 커널 스택에 그 프로세스 레지스터 값 저장

> 문맥 교환하는 데 걸리는 시간은 얼마인가
> 
> 
> 2 또는 3 GHz 프로세서의 경우
> 1마이크로초 미만이 소요된다.
> 
> 운영체제의 모든 동작이 CPU 성능에 따라 좋아지는 것이 아니라는 것에 주의하자
> 

## 병행성에 관한것

시스템 콜 중에 타이머 인터럽트가 발생한다면? 하나의 인터럽트 도중에 다른 인터럽트가 발생한다면??

처리하기 매우 어렵다.

이후 나올 병행성 내용 

운영체제가 할 수 있는 간단한 해법은 인터럽트를 처리하는 동안 인터럽트를
불능화시키는 일

이 작업을 신중하게 해야 한다. 인터럽트를 너무 오랫동안 불능화시키면 인터럽트를 놓치게 되고 기술적으로도 좋지 않다.

레이스 컨디션을 방지하기 위해 락(lock)기법을 개발

## 요약

운영체제는 CPU에 안전 장치를 준비해 놓는 것

그래서 나온 게 방법

1. 트랩 핸들러
2. 인터럽트 타이머
3. 제한된 모드에서만 프로세스 실행
4. 프로세스가 특별한 연산(시스템 콜)을 사용하거나 CPU를 독점하거나, 다른 프로세스로 전환해야 할 때만 개입한다. 

## 운영체제 라는 것은 무엇일까? 및 좀 더 찾아볼 것

- 편하게 사용하고 싶은 욕구
    - 자주 쓰이는 여러 기능을 만들 필요 없이, 제공된 인터페이스만 사용해도 되도록 (추상화)
- OS를 쓰면서 안정성도 보장해야 한다.
    - 편리하게 해주는 기능 자체가 잘못 덮여져서 망가지면 안 된다.
    - 중요한 것은 못 건드리게 만들어야 한다.

C의 전형적인 프로시저 호출이란? cdecl을 말하는 거 같다. 

스텁 코드란 무엇인가?

EBP, ESP 제외하고 커널 스택 포인터를 가리킬 레지스터는 무엇인가?