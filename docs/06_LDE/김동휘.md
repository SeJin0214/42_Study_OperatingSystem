# 제한적 직접 실행 원리

CPU가상화를 위해 운영체제는 여러 프로세스를 잠깐씩 실행시키며 CPU를 공유.  
그러나 이러한 가상화 기법 구현을 위해 몇 가지 문제를 해결해야 함.  

1. 성능 저하 : 시스템에 과도한 오버헤드를 주지 않으며 가상화 구현하기.
2. 제어 문제 : CPU에 대한 통제를 유지하며 프로세스 효율적 실행. 운영체제 입장에서 제어문제는 특히 중요함.  
</br>

</br>

## 기본 원리
운영체제 개발자들은 프로그램의 빠른 실행을 위해 제한적 직접 실행(Limited Direct Execution)이라는 기법을 개발함.  
프로그램을 CPU상에서 그냥 직접 실행시키는 것임.
1. 운영체제가 프로그램을 실행하려함
2. 프로세스 목록에 해당 프로세스 항목 만들기
3. 메모리 할당
4. 프로그램 코드를 디스크에서 탑재
5. 진입점(ex_main() 등)을 찾아 그 지점으로 분기
6. 사용자 코드 실행 시작
</br>
</br>

간단함.  
그러나, 몇 가지 문제를 일으킴.

- 프로그램 직접 실행시, 프로그램이 운영체제가 원치않는 일을 할 가능성 존재.
- 운영체제가 프로그램의 중단 및 다른 프로세스로 전환을 어떻게 할 것인가? 즉 시분할 기법 구현의 문제.

## 문제점 1 : 제한된 연산

직접 실행의 장점은 빠르게 실행된다는 것. 그러나 CPU에서 직접 실행시키면 새로운 문제가 발생함.

프로세스가 특수한 종류의 연산을 수행하길 바란다면?

- 프로세스가 원하는 대로 할 수 있게 방치하는 방안이 있으나, 바람직한 시스템을 구척하는 데에는 방해 요인이 됨.
- 프로세스의 디스크에 대한 입츨력을 제한하지 않으며 프로세스는 전체 디스크를 읽고 쓸 수 있기에 접근 권한 검사가 의미가 없음.
- 때문에, 사용자 모드(user mode)가 도입됨. 이 모드에서 실행되는 코드는 할 수 있는 일이 제한됨. 에를 들어 프로세스가 사용자 모드에서 실행중이면 입출력 요청을 할 수 없도록 설정함.
- 커널 모드(kernel mode)는 사용자 모드와 대비되어 운영체제의 중요한 코드들이 실행됨. 모든 작업을 수행할 수 있음.
  
사용자 프로세스가 디스크 일기와 같은 특권 명령을 실행할 때는 어떻게 해야하는가?

- 이에 대한 시스템 콜을 제공.
  - 시스템 콜을 통하여 파일 시스템 접근, 프로세스 생성 및 제거, 다른 프로세스와의 통신 및 메모리 할당 등 수백 개의 기능을 제공

### trap

시스템 콜 실행을 위해 프로그램은 trap특수명령어를 실행해야 함.

- 이 명령어는 커널 안으로 분기와 동시에 권한을 커널 모드로 상향시킴.
- 이에 따라 운영체제는 모든 명령어를 실행할 수 있고 이를 통해 요청한 작업을 처리 가능.  
- 완료되면 운영체제는 raturn-from-trap 특수 명령어를 호출함. 이 명령어는 특권 수준을 사용자 모드로 다시 하향시켜 호출한 사용자 프로그램으로 리턴함.  

</br>
</br>
</br>
</br>
## 제한적 직접 실행 프로토콜 <그림>
|운영체제 부트(커널모드)|하드웨어||
|-|-|-|
|트랩 테이블 초기화|||
||syscall 핸들러 주소 기억||

|운영체제 실행(커널모드)|하드웨어|프로그램(사용자모드)
|-|-|-|
프로세스 목록에 항목 추가. 프로그램을 위한 메모리 할당. 프로그램 메모리 탑재. argv를 사용자 스택에 저장. 레지스터와 PC를 커널 스텍에 저장. return-from-trap|||
||커널 스택으로부터 레지스터를 복원. 사용자 모드로 이동. main으로 분기||
|||main()실행 ... 시스템 콜 호출. 운영체제로 트랩|
||레지스터를 커널 스택에 저장. 커널 모드로 이동. 트랩 핸들러로 분기||
|트랩 처리. syscall임무 수행. return-from-trap|||
||커널 스택으로부터 레지스터 복원. 사용자 모드 이동. 트랩 이후의 PC로 분기||
|||main에서 리턴. trap(exit()을 통해)|
|프로세스 메모리 반환. 프로세스 목록에서 제거|||

이 그림은 메커니즘을 요약해서 나타냄

- 프로세스는 커널 스택을 각자 갖고 있음.
- 커널 모드 진입 및 진출시 하드웨어에 의해 프로그램 카운터와 범용 레지스터 등의 레지스터가 저장되고 복원되는 용도로 사용됨.
</br>

</br>

LDE(제한적 어쩌구)프로토콜은 두 단계로 진행됨.

- 전반부(부팅시)
  - 커널은 트랩 테이블을 초기화하고 CPU는 나중에 사용하기 위해 테이블 위치를 기억함.
  - 커널은 이러한 작업을 커널 모드에서만 사용가능한 명령어로 수행.
- 후반부(프로세스 실행시)
  - return-from-trap을 이용하여 사용자 프로세스 시작할 때 몇 가지 작업을 수행.(새로운 프로세스를 위한 노드를 할당하여 프로세스 리스트에 삽입, 메모리를 할당하는 등)
  - return-from-trap명령어는 CPU를 사용자 모드로 전환하고 프로세스 실행을 시작.
  - 프로세스가 시스템 콜 호출하면 운영체제로 다시 트랩됨.
  - 운영체제는 시스템 콜을 처리하고 return-from-trap 명령어를 통해 제어를 다시 프로세스에게 넘김.
  - 프로세스는 이후 할 일을 다하면 main()에서 리턴.
  - 이때 일반적으로 스텁 코드로 리턴하고, 스텁 코드가 프로그램을 종료시킴.
  - 종료시킬 때 exit() 시스템을 호출하고 다시 운영체제로 트랩.
  - 이 시점에 운영체제는 정리작업을 하며 모든일이 완료됨.
</br>

</br>
</br>
## 문제점 2: 프로세스 간 전환
직접 실행의 두 번째 문제점은 프로세스 간 전환을 할 수 있어야 한다는 것.  
운영체제는 실행중인 프로세스를 계속 실행할지 멈추고 다른 프로세스를 실행할 것인지 결정해야 함.  
</br>

CPU에서 프로세스가 실행중 -> 운영체제는 실행중이지 않다는 것. CPU에서 실해하고 있지 않다면 운영체제는 어떠한 조치도 취할 수 없음.
> 핵심 질문 : 운영체제는 CPU를 어떻게 다시 획득해서 프로세스를 전환할 수 있을까?

</br>

### 협조 방식 : 시스템 콜 기다리기

협조 방식은 과거 몇몇 시스템에서 채택되었던 방식.

- 이 방식에서는 운영체제가 프로세스들이 합리적으로 행동할 것이라 신뢰함
  - 너무 오래 실행할 가능성이 있는 프로세스는 운영체제가 다른 작업을 실행할 결정을 할 수 있도록 주기적으로 CPU를 포기할 것이라 가정.
- 이러한 이상적 환경에서 우호적 프로세스는 어떻게 CPU를 포기할 수 있을까?
  - 대부분의 프로세스는 자주 시스템 콜을 호출하여 CPU의 제어권을 운영체제에게 넘겨줌. 예를 들어 파일을 열고 읽는 작업을 한다거나 다른 컴퓨터에게 메시지를 송신하거나 또는 새 프로세스를 생성하는 등의 시스템 콜을 호출함.
  - 응용 프로그램이 비정상적인 행위를 하면 운영체제에게 제어가 넘어감. 예를 들어 응용 프로그램이 어떤 수를 0으로 나누거나, 접근 불가 메모리에 접근하려 하면 운영체제로의 트랩이 일어나, 운영체제는 CPU를 획득하여 해당 행위를 하는 프로세스를 종료할 수 있음.
- 협조방식의 스케줄링 시스템이서 운영체제는 시스템 콜이 호출되기를 기다리거나 불법적인 연산이 일어나기를 기다려서 CPU의 제어권을 다시 획득함.

### 비협조 방식 : 운영체제가 전권을 행사

프로세스가 시스템 콜을 호출하길 거부하거나 실수로 호출하지 않아 운영체제에게 제어르 넘기지 않을 경우 하드웨어의 추가적 도움없이는 운영체제가 할 수 있는 일이 거의 없음.  
협조적 방법에서 프로세스가 무한루프에 빠졌을 경우 할 수 있는 일은 컴퓨터 재부팅밖에 없음.
> 협조 없이 제어를 얻는 방법?  

해결책은 타이머 인터럽드(timer interrupt).
</br>
</br>

### 타이머 인터럽트

수 밀리 초마다 인터럽트를 발생시키도록 프로그램 가능.  

- 인터럽트 발생 시 현재 수행중인 프로세스는 중단되고 미리 구성된 운영체제의 인터럽트 핸들러(interrupt handler)가 실행됨.
- 이 시점에 운영체제는 CPU제어권을 다시 얻게 되고 자신이 원하는 일을 할 수 있음.

> 타이머 인터럽트 하드웨어 기능은 운영체제가 컴퓨터의 제어를 유지하는 핵심적인 기능!  

- 부팅과정 진행 중 운영체제는 타이머를 시작함.
- 타이머 시작시 운여에제는 자신에게 제어가 돌아올 것이라 믿고 부담없이 사용자 프로그램을 실행할 수 있음.
- 타이머는 특정 명령어로 끌 수도 있음.

인터럽트 발생시 실행중이던 프로그램의 상태를 저장하여 추후 return-from-trap 명령어가 프로그램을 다시 시작할 수 있도록 해야 함.
</br>
</br>
</br>

### 문맥의 저장과 복원

협조적, 또는 타이머 인터럽트를 통한 강제시, 운영체제가 제어권을 다시 획득하면 현재 프로세스를 계속 실행할 것인지 다른 프로세스로 전환할 것인지 결정해야 함. 이 결정은 운영체제의 스케줄러(scheduler)라는 부분에 의해 내려짐.  
다른 프로세스로 전환하기로 결정되면 운영체제는 문맥교환(context switch)라는 코드를 실행한다.  

    * 문맥교환
    운영체제가 해야 할 작업은 현재 실행중인 프로세스의 레지스터 값을 커널 스택 등에 저장하고, 곧 실행될 프로세스의 커널 스택으로부터 레지스터 값을 복원하는 것.  

이를 통해 운영체제는 return-to-trap 명령어가 마지막으로 실행될 때 현재 프로세스가 아닌, 다른 프로세스로 리턴하여 실행을 다시 시작할 수 있음.  

- 프로세스 전환을 위해 운영체제는 저수준 어셈블리 코드로 현재 실행중인 프로세스의 범용 레지스터, PC 뿐만 아니라 현재 커널 스택 포인터를 저장.
- 그리고 곧 실행 될 프로세스의 범용 레지스터, PC를 복원하고 컨러 스택을 이 프로세스의 커널 스택으로 전환.
- 이로써 운영체제는 인터럽트 된 프로세스 문맥에서 전환 코드 호출, 실행될 프로세스 문맥으로 리턴 가능.
- 마지막으로 return-from-trap 명령어 실행시 곧 실행될 프로세스가 현재 실행중인 프로세스가 됨.
- -> 문맥 교환 마무리
</br>

</br>
이하 모든 과정의 연대표

## 제한적 직접 실행 프로토콜 (타이머 인터럽트)<그림>

|운영체제 부트(커널모드)|하드웨어||
|-|-|-|
|트랩 테이블 초기화|||
||syscall 핸들러, 타이머 핸들러 주소 기억||
|인터럽트 타이머 시작|||
||타이머 시작. X msec지난 후 CPU를 인터럽트||

</br>
</br>

|운영체제 실행(커널모드)|하드웨어|프로그램(사용자모드)
|-|-|-|
|||프로세스 A|
||타이머 인터럽트. A의 레지스터를 A의 커널 스택에 저장. 커널 모드로 이동. 트랩 핸들러로 분기||
|트랩을 처리. switch()루틴 호출. A 레지스터를 A의 proc 구조에 저장. B의 proc구조로부터 B의 레지스터 복원. B의 커널 스택으로 전환. return-from-trap(B 프로세스로)|||
||B의 커널 스택을 B의 레지스터로 저장. 사용자 모드로 이동. B의 PC로 분기||
|||프로세스 B ...|

</br>
</br>

### 병행성 걱정

만약 시스템 콜 처리도중 타이머 인터럽트가 발생한다면? 혹은 하나의 인터럽트를 처리하고 있는데 다른 인터럽트가 발생한다면? 커널에서 처리하기 더 어려워진게 아닌가?  
-> 어려워짐.  
운영체제가 인터럽트 또는 트랩 처리 도중 다른 인터럽트가 발생하는 것은 병행성에 관한 것.(추후 논의)  
</br>
</br>

#### 이러한 상황을 처리하는 방법(간략히)

간단한 해법은, 인터럽트가 처리되는 동안 다른 인터럽트를 불능화 시키기

- 하나의 인터럽트가 처리되는 동안 다른 어떠한 인터럽트도 CPU에 전달되지 않음.
- 물론, 운영체제는 이 작업을 신중히 해야 함. 인터럽트를 너무 오래 불능화 시키면 인터럽트를 놓치게 되어 기술적으로 좋지 않음.  

</br>
</br>
운영체제는 내부 자료구조에 동시접근하는 것을 방지하기 위해 많은 정교한 락 기법을 개발해 옴. 이 잠금 기법은 커널 안에서 동시에 다수 활동이 진행될 수 있도록 허용.
