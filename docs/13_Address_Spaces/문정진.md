# 주소 공간의 개념
## 16.1 초기 시스템
초기 컴퓨터는 물리 메모리에 실행 중인 프로그램이 존재하고, 나머지 메모리 사용.
가상화는 존재 하지 않았음.
## 16.2 멀티프로그래밍과 시분할
멀티프로그래밍 시대
* 여러 개의 프로세스가 실행 준비 상태 있으며, 운영체제가 전환하며 실행. 전환은 CPU의 이용률 증가 시킴, 해당 부분이 효율성 개선이 중요했음.
시분할 시대
* 일괄처리방식 컴퓨팅의 한계를 느낌. 많은 사용자가 동시에 컴퓨터 사용하고, 실행 중인 작업으로 부터 즉각적인 반응이 필요하여 대화식 이용의 개념이 중요하게 됨.
시분할 구현 방법
* 프로세스를 짧은 시간 동안 실행 시키기 -> 해당 시간 동안 프로세스에게 모든 메모리 접근 권한을 줌 ->
 그 후 해당 프로세스를 중단 -> 중단 시점의 모든 상태를 디스크에 저장 -> 다른 프로세스의 상태를 탑재해 짧은 시간 동안 실행 -> 시분할을 구현.
   * 문제점 : 느리게 동작. 메모리가 커질수록 더 느려짐. 레지스터 상태 저장 복원은 빠르나 메모리의 내용 전체를 디스크 저장시 느림.
> 시분할 시스템의 대중화로 여러 프로그램이 메모리에 동시애 존재하려면 보호가 중요한 문제가 됐음.
## 16.3 주소 공간
주소 공간 (address space)
* 메모리 동시 존재를 보호하기 위해 운영체제는 사용하기 쉬운 메모리 개념을 만들어야함.
* 운영체제 메모리 개념 이해하는 것이 메모리 가상화의 핵심.
* 주소 공간은 프로세스의 모든 메모리 상태를 갖고 있음.
    * 코드(code, 명령어) = 반드시 메모리에 존재해야함, 정적이기 떄문에 메모리 저장 쉬움.
    메모리 상단에 배치, 프로그램 실행 되면 추가적으로 메모리가 필요하지 않음.
    * 스택 = 함수 호출 체인 상의 현재 위치, 지역 변수, 함수 인자와 반환 값 저장.
    프로그램 실행과 더불어 메모리 확장되거나 축소될 수 있음. 코드를 제외한 상단에 배치, 힙은 하단에 배치하며 메모리 크기를 확장, 축소를 위해서 끝단에 위치함.
    * 힙(heap)  = 동적 할당(malloc), 메모리 하단에 배치.
    * 메모리 배치는 관례일 뿐, 멀티 쓰레드의 경우 해당 방식으로 공간을 나누지 않음.
* 실제로 프로그램이 물리 주소 사이에 존재하는 것은 아님, 실제로는 임의의 물리 주소에 탑재됨.
* 메모리 가상화 = 실행중인 프로그램은 특정 주소의 메모리에 탑재됨, 프로세스마다 메모리 크기가 다르기 때문에 메모리 크기에 맞는 부분을 보장하여 해당 주소에 저장.
## 16.4 목표
> 고립의 원칙. 고립은 신뢰할 수 있는 시스템 구축의 중요 원칙. 두 개체가 서로 적절하게 고립된 경우, 한 쪽이 실패하더라도 나머지에게 영향을 주지 않음. 메모리 고립은 프로그램이 운영체제 동작에 영향을 줄 수 없음.
가상 메모리 시스템 목표
* 투명성(transparency)
    * 실행 중인 프로그램이 가상 메모리의 존재를 인지하지 못하게 해야함.
    * 프로그램이 전용 물리 메모리 소유한 것처럼 행동해야함.
* 효율성(effciency)
    * 가상화가 시간과 공간 측면에서 효율적이게 해야함.
    * 프로그램이 느리게 실행되서 안되고, 공간적으로 가상화 지원을 위해 많은 메모리 사용 해선 안됨.
    * 시간 효율적인 가상화 구현 시 TLB 등 하드웨어 기능 포함하여 지원 받아야함.
* 보호 (protection)
    * 운영체제는 프로세스를 다른 프로세스로 부터 보호해야하고, 운영체제 자신도 보호해야함.
    * 프로세스 탑재 및 저장, 명령어등 어떤 방법으로든 다른 프로세스나 운영체제 메모리에 접근해서는 안 됨.
##  16.5 요약
>  vm 시스템은 프로세스 전용 공간이라는 환상을 프로그램에게 제공 책임 있음. 해당 공간에 명령어 전부, 데이터 전부 저장. 운영체제는 가상 메모리 주소를 물리 주소로 변환, 물리 주소는 원하는 정보 반입 위해 물리 메모리에게 전달.