# 주소 공간의 개념

컴퓨터 시스템을 구현하는 것이 점차 어려워지는 이유는 "사용자 편의", "고성능", "신뢰성" 등을 요구하기 때문이다.  
</br>
</br>

## 1. 초기 시스템

메모리 관점에서 초기 컴퓨터는 단순했다.

- 운영체제는 메모리에 상주하는 루틴의 집합이였다. (예를 들어 0KB 부터 64KB까지 차지하고 있다)
- 물리 메모리에 하나의 실행중인 프로그램(프로세스)이 존재하였고, 나머지 메모리를 사용하였다. (64KB부터 쭉)
- 특별한 가상화는 거의 존재하지 않았다.  
  
	<img src="image\초기운영체제.png" width="300" height="400">
</br>
</br>

## 2. 멀티프로그래밍과 시분할

이후 더 효과적으로 컴퓨터를 공유하기 위해 멀티프로그래밍(multi-programming)이 도입된다.

- 여러 프로세스가 실행 준비상태에 있고 운영체제는 그들을 전환하면서 실행하였다.
  - 예_한 프로세스가 입출력 실행시 CPU는 다른 프로세스로 전환
- 전환을 통해 CPU 이용률을 증가시켰다.

</br>

그리고, 컴퓨터를 보다 많이 사용하기 위해 시분할(time-sharing)이 도입된다.

- 일괄처리방식(batch computing)의 한계를 인식하였다.
  - 특히 오랜 시간이 걸리는 프로그램-디버그 사이클이 있다.
- 많은 사용자가 동시에 컴퓨터를 사용하고 헌재 작업으로부터 즉시 응답을 원했기에 대화식 이용(interactivity) 개념이 중요해졌다.
- 구현 방식 중 하나는, "하나의 프로세스를 짧은 시간 실행"시키는 것이다.
  - 해당 기간동안 프로세스에게 모든 메모리 접근권한을 부여한다.
  - 이후, 이 프로세스를 중단하고, 중단시점의 모든 상태를 저장장치에 저장한다.
  - 그리고 다른 프로세스 상태를 탑재하여 다시 짧은 시간 실행시킨다.
- 짧은 시간 시분할의 문제점
  - (메모리가 커질 수록) 너무 느리게 동작한다.
  - 레지스터 상태를 저장 및 복원하는 것은 빠르나, 메모리 내용 전체를 디스크에 저장하는 것은 매우 느림.


|세개의 프로세스 : 공유메모리||
|-|-|
|* rmfladp 3개의 프로세스가 있다.</br> * A는 프로세스</br>* B, C는 준비 큐에서 실행을 기다림.</br></br></br></br></br></br></br></br></br></br></br></br></br></br></br>|</br><img src="image\공유메모리.png" width="400" height="400">|

</br>

- 시분할 시스템의 대중화로 생긴 문제 : 여러 프로그램이 메모리에 동시에 존재할 때 보호(protection)  
  - 한 프로세스가 다른 프로세스의 메모리를 읽거나 악용하는 것을 막기.


## 3. 주소 공간
프로세스간 메모리 침범과 악용을 막기 위해 운영체제는 사용하기 쉬운(easy to use) 메모리 개념을 만들어야 한다.  
이 개념이 주소 공간(addres space)이다.  
메모리 가상화를 위해 운영체제의 메모리를 먼저 이해해야 한다.  

</br>

- 주소공간은 실행프로그램의 모든 메모리 상태를 갖고 있다. 
  - 코드는 반드시 메모리에 존재해야 하기에 주소공간에 존재. 
  - 스텍은 함수호출 체인상 현재 위치, 지역변수, 함수인자, 반환값 등을 저장.
  - 힙은 동적으로 할당되는 메모리에 사용.  

</br>
</br>

- 아래 그림은 아주 작은 주소공간이다.
  - 프로그램 코드
    - 주소공간 위쪽에 위치한다. 
    - 코드는 정적이기 때문에 메모리 저장이 쉽다. 
    - 따라서 상단 배치 및 추가메모리가 필요하지 않다.
  - 힙 + 스텍
    - 확장되거나 축소될 수 있어야 한다.
    - 그러므로 주소공간의 양 끝단에 배치해야한다.
    - 확장 방향이 반대방향일 수 밖에 없다.
    - 이는 관례일 뿐, 다른 방향으로도 배치 가능.
  - (나중에) 주소공간에 여러 쓰레드가 공존할 시 이런 식으로 공간을 나누면 동작하지 않음.

</br>

<img src="image\주소공간의 예.png" width="400" height="400">
</br>
</br>

- 주소공간에서 운영체제가 실행중인 프로그램에게 제공하는 개념(abstraction)
  - 실제로는 물리주소 0에서 16KB 이렇지 않고 임의의 물리주소에 탑재된다.
> 핵심질문 : 메모리를 어떻게 가상화 하는가?  
> 운영체제는 물리메모리를 공유하는 다수 프로세스에게 어떻게 프로세스 전용인 커다란 주소공간이라는 개념을 제공하는가?
</br>

- 운영체제가 이 일을 하는 것을 메모리 가상화(virtualizing memory)라고 한다.
  - 왜냐하면, 실행중인 프로그램이 자신이 특정 주소 메모리에 (에를 들어 0) 탑재되고 매우 큰 주소공간(예를 들어 32, 64bit)을 가지고 있다고 생각하기 때문이다.
  - 아래 그림에서는 A가 (가상)주소 0부터 연산수행할 때 운영체제는 하드웨어 지원을 통해 물리주소 0이 아니라 320KB를 읽도록 해야 한다.  
  	 <img src="image\공유메모리.png" width="300" height="300">
  - 이것이 메모리 가상화의 열쇠이자, 현대 모든 컴퓨터 시스템의 기초이다.

</br>
</br>

## 4. 목표
이제 메모리 가상화를 논한다.  
메모리 가상화 뿐만 아니라 이를 멋지게 표한하기 위한 몇 가지 목표를 설명한다.

1. 투명성(transparency)
   - 실행중인 프로그램이 가상 메모리의 존재를 인식하지 못하도록 구현해야 한다.
     - 오히려 프로그램이 자신이 전용 물리엔진 메모리를 소유한 것 처럼 행동해야 한다. 
     - 무대 뒤에서 운영체제와 하드웨어가 모든 작업을 수행한다.
2. 효율성(efficiency)
   - 가상화가 시간과 공간측면에서 효율적이도록 해야 한다.
     - 시간적으로는 너무 느리게 실행되지 않도록
     - 공간적으로는 가상화 지원을 위한 너무 많은 메모리가 사용되지 않도록
   - 시간-효율적 가상화를 구현할 때 운영체제는 TLB(나중에 배움)등의 하드웨어 지원을 받아야 한다.
3. 보호(protection)
   - 프로세스를 다른 프로세스로부터 보호하고, 운영체제 또한 프로세스로부터 보호받아야 한다.
     - 프로세스가 탑재, 저장, 명령어 반입과정에서 어떤 방법으로도 다른 프로세스 및 운영체제 메모리에 접근하거나 영향을 주면 안된다.
     - 즉, 자신의 주소공간 밖 어느 것도 접근할 수 있으면 안된다.
   - 우리는 프로세스들을 서로 고립(isolate)시켜야 한다.  
</br>

	> 고립의 원칙  
		두 개체가 서로 적절히 고립된 경우 한 개체가 실패해도 상대 개체에 아무런 영향을 주지 않는 것.  
		운영체제는 프로세스를 서로 고립시키기 위해 노력하고, 서로 피해주는 것을 방지한다.  
		더 나아가 메모리 고립을 통해 프로그램이 운영체제에 영향을 줄 수 없음을 보장한다.  
		이러한 마이크로커널은 전통적인 모놀리식 커널보다 더 큰 신뢰성을 보장한다  

</br>
</br>

	> 여담 : 우리가 보는 모든 주소는 가상주소이다.  
	
	종종 16진수로 출력되는 모든 주소값은 가상주소이다. 
	사용자 프로그램이 볼 수 있는 주소는 모두 가상주소라 할 수 있다.
	메모리 가상화기술로 인해, 물리 메모리 주소를 알 수 있는 것은 오직 운영체제 뿐이다. 
	오직 운영체제와 하드웨어만이 진실을 알 수 있다.