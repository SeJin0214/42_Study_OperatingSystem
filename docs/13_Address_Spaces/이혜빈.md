# 16. 주소 공간의 개념

> 초기 컴퓨터 시스템은 간단했음.  
> 하지만 **사용의 편의, 고성능, 신뢰성**이라는 목적 때문에 현재 컴퓨터 시스템은 복잡해졌다.


## 16.2 멀티 프로그래밍과 시분할

효과적인 컴퓨터(자원) 공유를 위해 멀티프로그래밍 시대가 열림.  
여러 프로세스가 ready상태에 존재하고, 운영체제는 프로세스를 전환하며 실행.  
-> 이로 인해 **CPU 이용률**, 즉 **효율성**이 높아졌다.  

더 높은 효율성을 위해 시분할(time-sharing)이 시작되며 일괄처리방식(batch computing)에서  즉시 응답을 하는 대화식 이용(interactivity)개념이 더 중요해짐.

#### 간단한 시분할 구현 방법
```text
1. 일정 시간동안 a 프로세스에게 모든 메모리 접근 권한을 줌
2. 시간이 끝나면, a 프로세스를 중단하고, 중단 시점의 모든 상태를 디스크에 저장
3. b 프로세스 실행 
... 반복
```

이 방법의 문제. 느리다. 특히 메모리가 커질 수록 더 느리다.  
따라서 운영체제는 프로세스 전환 시 프로세스를 메모리에 그대로 유지하면서 시분할 시스템을 효율적으로 구현해야 한다.  
즉, 프로세스들은 같은 메모리에 올라가 있게 된다.(공유 메모리)  
이로 인해 프로세스들이 다른 프로세스에 접근하지 않도록 **보호**하는게 중요해짐.  

## 16.3 주소 공간

때문에 운영체제는 사용하기 쉬운 메모리 개념(**주소공간(=address space)**)을 만듦.   
주소 공간은 실행 프로그램의 모든 메모리 상태(코드, 스택, 힙)를 가진다.  
- 코드 : 프로그램의 코드, 명령어. 
- 스택 : 함수 호출 체인 상의 현재 위치, 지역 변수, 함수 인자, 반환 값 등을 저장
- 힙 : 동적으로 할당되는 메모리 (ex. malloc(), new )
  
![Untitled](image\Memory_space.png)

코드 : 정적, 추가메모리 필요 x  
스택 : 아래 -> 위로 확장. 사용자가 프로시저를 호출할 때 확장 됨.  
힙 : 위 -> 아래로 확장. 동적 메모리가 할당될 때.

하지만 이렇게 주소 공간을 나누는 것은 멀티 쓰레드에서는 동작하지 않음.  

> 물리 메모리를 공유하는 여러 프로세스에게 어떻게 하나의 프로세스만을 위한 주소 공간을 제공할 수 있을까?
>> 이렇게 메모리 주소를 제공하는 것은 **가상 메모리 주소**이고, 운영체제는 가상 메모리 주소를 위해 **메모리 가상화(virtual memory)** 를 한다.

## 16.4 메모리 가상화(VM)의 목표

1. 투명성(transparency)  
	운영체제는 실행 중인 프로그램이 가상 메모리의 존재를 인지하지 못하게 해야 한다.
	프로그램은 메모리가 가상화 되었다는 사실을 몰라야 한다.
2. 효율성 (efficiency)
	운영체제는 시간, 공간적 측면에서 효율적으로 가상화 해야 한다.  
	시간적으로 너무 느리게 실행되어서도, 가상화 구조에 너무 많은 메모리를 사용해서도 안된다.  
	이를 위해 TLB와 같은 하드웨어 기능을 활용.
3. 보호 (protection)
	운영체제는 프로세스를 다른 프로세스로부터 보호하고, 운영체제 자신도 프로세스로부터 보호해야 한다.  
	프로세스가 실행될 때 어떤 방법으로든 다른 프로세스나 운영체제의 메모리 내용에 접근하거나 영향을 줄 수 있어서는 안된다.  
	즉, 프로세스들은 서로 고립 (isolate)되어야 한다.

## 요약
가상 메모리 시스템은 프로그램에게 프로세스 전용 공간이 있다는 환상을 제공해야 한다.
