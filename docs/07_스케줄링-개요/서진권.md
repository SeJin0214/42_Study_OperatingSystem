# 스케줄링 개요

## 7.1 워크로드에 대한 가정

>워크로드 : 프로세스가 동작하는 일련의 행위  
* 시스템에서 실행 중인 프로세스 혹은 작업에 대한 가정
1. 모든 작업은 같은 시간 동안 실행된다.
2. 모든 작업은 동시에 도착한다.
3. 작업은 일단 시작하면 최종적으로 종료될 때까지 실행된다.
4. 모든 작업은 CPU만 사용한다. (즉, 입출력은 사용하지 않는다)
5. 각 작업의 실행 시간은 사전에 알려져 있다.  

## 7.2 스케줄링 평가 항목

> T(turnaround) = T(completion) - T(arrival)    

모든 작업은 동시에 도착한다 라고 가정 -> T(turnaround) = T(completion) - 0;

## 7.3 선입 선출 -> FIFO(first in first out)

작업 A B C의 프로그램이 거의 동시에 도착했다. 그렇다면 T_t는 어떻게 될까? (각 작업은 10초 동안 작동)
>T_t = (10 + 20 + 30)/ 3 = 20이다.

음…. 자원이 골고루 분배되는 것 같다. 하지만 A의 작업이 만약 100초가 소모된다면?
우리의 가정3길을 생각하면서 한번 생각해 보자.
>T_t = (100 + 110 + 120)/ 3 = 110이다.

음…. 약간의 문제가 발생했다. 나는 분명 콜라 한 잔만 사면되는데 나보다 10^-10000000초 먼저 도착한 건설 현장 식자재 계산이 있는 느낌
내가 이걸 왜 기다려야 하는 거지??? 라는 생각이 들면서 다른 방법을 찾아보게 되는데!! 두둔 등장(convoy effect)

## 7.4 최단 작업 우선 -> SJF(Shortest Job Fisrt)
좋아 우리는 방법을 찾았다. 가정 2가 항상 true라면 SJF는 엄청나게 좋은 방법이다.
T_t를 계산해 보도록 하자
>T_t = (10 + 20 + 120) / 3 = 50

캬 아주 좋다. 무려 평균 반환 속도가 2배 이상 향상이 되었다.!!!비슷하게 도착했다면 콜라 한잔 사는 사람 먼저 계산해 주는 느낌 배려를 받는 느낌이다.
하지만 인생은 호락호락하지만은 않다.!!! 만약 가정 2가 True가 아니라면???
(모든 작업은 동시에 도착한다)머리가 복잡해진다.
건설 현장 식자재를 계산은 도중 10초 뒤에 콜라 한잔 산 사람이 왔다. T_t는 어떨까?
>T_t = (100 + (110 - 10) + (120 - 10))/3 = 103.333….

콜라 한잔 사려는 사람은 너무 화가 난다. 정당한 방식이지만 그래도 감정이 요동친다. 다른 방법은 없을까???

## 7.5 최소 잔여시간 우선 -> STCF(Shoortest Time-to-Completion First)
>문제를 해결하기 위해서는 가정3길을 완화한다.

>이제는 새로운 예시를 들어야겠다. 내가 군대에 있을 때 PX(군대 마트)에는 신기한 방식이 존재했는데
주말에 PX는 사람들이 차고 넘친다. 물건들을 많이 사는 사람들이 많기 때문에 계산 시간도 매우 오래 걸렸는데
물건을 살 때 엄청나게 급한 사람이 누구일까? (물론 PX는 모두가 급하다. ) 바로 흡연자!!!흡연자들은 다른 사람들이 과자를 가득 살 때 자신은 담배만 사는데 줄 서는 것을 못마땅했는데,
그래서 PX는 새로운 정책을 만들었다. 바로 담배만 사는 사람들은 다른 사람들이 계산하는 도중에 담배만 먼저
따로 계산하게 해주는 것…. 이렇게 되면 담배만 사는 사람들은 오래기다리지 않아도 된다!!!


이 정책을 비슷하게 받아들인 게 STCF이다. 작업시간이 작은 작업은 긴 작업이 수행 중이더라도 잠시 중단 후
작업시간이 작은 것을 먼저 실행시킨다. T_t는 어떨까?
>T_t = (120 + (20 - 10) + (30 - 10))/3 = 50

Wow 최적의 스케줄이다 !!!
> 작업의 길이를 미리 알고, 작업이 오직 CPU만 사용하며, 평가 기준이 반환시간 하나라면 매우 훌륭한 정책이다. 

## 7.6 새로운 평가 기준 : 응답 시간

우리는 시분할이라는 개념을 알고 있다.
즉 우리는 반환시간보다 시스템에서 상호작용을 원활하다 하려는 성능을 요구하게 되었고
응답시간이라는 새로운 평가 기준이 만들어졌다.
>T_response = T_firstrun - T_arrival

그림 7.5의 T_r을 계산해 본다면
(A는 시간 0, B와 C는 시간 10에 도착) 평균 T_r은 3.3…. 이 된다.
음…. 생각을 위의 STCF와 비슷한 정책들은 반환 시간 방면에서는 너무 좋다.
하지만 응답시간을 생각해 본다면 C의 응답시간은 무려 10초나 기다려야 한다. ㅠㅠㅠ
응답 시간을 최소화할 방법이 있을지 생각을 해보자.

## 7.7 라운드 로빈 -> (Round-Robin)
>기본 발상
작업이 끝날 때까지 기다리지 않는다.
대신 일정 시간 동안 실행한 후 실행 큐의 다음 작업으로 전환한다.
작업이 실행되는 일정 시간을 타임 슬라이스 또는 스케줄링 퀀텀이라고 한다.

그림 7.6의 T_r은 평균 5초, 그림 7.7의 T_r은 평균 1초이다.
그림과 같이 타임슬라이스가 짧을수록 T_r 기준으로 RR의 성능은 향상된다.
하지만 문맥 교환 비용이 전체성능에 큰 영향을 미치게 된다.
그래서 설계자는 시스템이 최적의 상태로 동작할 수 있도록 타임 슬라이스를 조정해야 한다.
> SJF, STCF 는 반환 시간 측면에서는 좋은 성질을 보이지만, 응답 시간은 좋지 않다.
RR은 응답 시간 측면에서는 좋지만, 반환 시간 측면에서는 좋지 못한 특성을 가지고 있다.

## 7.8 입출력 연산의 고려
* 가정 4, 5를 완화한다.

우선 가정 4를 완화해 보자. (입출력)
그림 7.8을 보도록 하자.
작업 A는 10msec 동안 실행 후, 입출력 요청을 한다.
작업 B는 입출력을 실행하지 않는다.
그림 7.8처럼 실행하게 되면 입출력 요청을 받는 동안 CPU는 놀고 있게 된다.
STCF스케줄러를 이용해서 두 개의 작업 A, B를 처리하고자 한다면 어떨까?
작업 A의 5개의 10msec의 작업을 독립적인 작업으로 간주한다.
A가 입출력 작업을 받는 동안 B 작업을 수행 후 A가 다시 투입 반복을 한다.
그림 7.9처럼 스케줄을 하게 된다면 CPU의 이용률이 더 높아지게 된다.