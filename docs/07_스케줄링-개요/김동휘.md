# 스케줄링: 개요
스케줄링 정책 (scheduling policy) == 원칙(discipline)  
</br>
## 1. 워크로드에 대한 가정
워크로드(workload) : 일련의 프로세스들이 실행하는 상황
- 모든 작업은 같은 시간동안 실행될 것
- 모든 작업은 동시에 시작될 것
- 각 작업은 시작되면 완료될 때 까지 실행 될 것
- 모든 작업은 CPU만 사용할 것(입출력 수행 안함)
- 각 작업의 실행시간은 사전에 알려짐
</br>
## 2. 스케줄링 평가 항목
워크로드에 대한 가정 이와에 스케줄링 정책의 비교를 위해 결정해아 하는 항목
1. 반환시간(turnaround time) 
	: 작업이 완료된 시각 - 작업이 시스템에 도착한 시간
	모든 작업은 동시에 시작될 것으로 가정했기에 arrival==0  
	즉, turnaround == complition
  
## 3. 선입선출
- 선입선출(FIFO)스케줄링은 단순하고 구현이 쉽다.
- convoy effect라는 문제점이 존재한다.
- convoy effect : 짧은 시간동안 자원을 사용할 프로세스들이 자원을 오랫동안 사용하는 프로세스의 종료를 기다리는 현상

## 4. 최단 작업 우선
- Shortest Job First; SJF
- 가장 짧은 실행 시간을 가진 작업을 먼저 실행시킨다.
- 앞선 비현실적 가정을 배제한다면 다시 문제가 발생한다.
- 동시에 도착하지 않는다면 또다시 convoy effect가 발생한다.

## 5. 최소 잔여시간 우선
- Shortest Time-to-Completetion First; STCF
- 이에 앞서 가정3(작업을 완료까지 실행할 것)을 배제한다.
- 더 짧은 실행시간을 가진 작업이 후에 도착했을 때 앞선 작업을 중지할 수 ㅇ씨다. 
- 최단 작업 우선(SJF)는 비선점형 스케줄러이기에 이와같은 동작이 불가능하다.

## 6. 새로운 평가기준 : 응답시간
시분할 컴퓨터의 등장 후 사용자는 터미널에서 작업하게 되어 시스템에게 상호작용을 원할히 하기위한 성능이 필요해졌다  
이로 인해 응답시간(response time)이라는 평가기준이 생긴다.  
(앞서 배운 STCF같은 정책은 응답시간이 길다. 3개의 작업이 동시도착할 경우 작업은 딱 한 번 스케줄 되기위해 먼저 실행된 두 작업이 완전히 끝날 때 까지 기다린다. 반환시간 측면으로는 훌륭하나, 응답시간 및 상호작용 측면에서는 매우 나쁘다.)
</br>
응답시간 : 작업이 도착한 시간부터 처음 스케줄 될 때 까지의 시간
T response = T fistrun - T arrival

## 7. 라운드 로빈
라운드 로빈(Round-Robin; RR) : 응답시간 문제를 해결하기 위한 스케줄링 알고리즘
- 작업이 끝날 때 까지 기다리지 않고 일정 시간 실행 후 실행 큐의 다음 작업으로 전환한다.
- 이 때 작업이 실행되는 일정 시간을 타임 슬라이스(time slice) 또는 스케줄링 퀀텀(scheduling quantum)이라 한다. 그러므로 RR을 타임 슬라이싱이라고도 한다.
- 타임 슬라이스가 짧을 수록 응답시간이 좋아지지만, 너무 짧게 지정시 문맥 교환 비용이 커진다. 문맥 교환 비용을 상쇄할 수 있을만큼 길고 응답시간은 짧게 적절히 조절이 필요하다.
- RR은 반환시간 기준으로 최악의 정책이다.

## 8. 입출력 연산의 고려
이번엔 가정 4(입출력을 하지 않는다)를 배제한다. 모든 프로그램은 입출력 작업을 수행한다.  
입출력 요청을 발생시킨 작업은 입출력 완료를 기다리며 대기상태가 된다. 스케줄러는 그 시간동안 실행될 다른 작업을 스케줄 해야 한다.  
마찬가지로 스케줄러는 입출력 완료 시에도 의사 결정을 해야 한다. 입출력이 완료되면 인터럽트가 발생하고 운영체제가 실행되어 입출력을 요청한 프로세스를 대기->준비로 이동시킨다.  
-마치 STCF의 방식처럼 프로세스의 입출력이 끝나기를 기다리는 동안 CPU는 다른 프로세스에 의해 사용되어 연산의 중첩을 가능하게 한다.

## 9. 만병통치약은 없다
마지막 가정(스케줄러가 각 작업의 실행시간을 알고 있다는 가정)은 불가능. 범용 운영체제에서 작업의 길이에 대해 알 수있는 길은 없다.