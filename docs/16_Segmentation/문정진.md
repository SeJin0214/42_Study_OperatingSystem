# 세그멘테이션
베이스와 바운드 레지스터 사용 시 운영체제는 프로세스를 물리 메모리에 쉽게 재배치 가능.
스택과 힙 사이에 사용되지 않는 큰 공간 존재.
베이스와 바운드 레지스터는 해당 부분에 대해서 메미로 낭비가 심함.
베이스와 바운드 레지스터는 유연성이 없음.
## 19.1 세그멘테이션 : 베이스 /  바운드의 일반화
> 세그멘테이션(segmentat-tion) :
* MMU 하나의 베이스와 바운드 쌍이 존재하는 것이 아닌, 주소 공간의 논리적인 세그멘트마다 베이스와 바운드 쌍이 존재.
* 세그멘트는 특정 길이를 가지는 연속적인 주소 공간. 코드, 스택, 힙의 세 종류의 세그멘트 있음.
* 세그멘트를 물리 메모리의 각기 다른 위치에 배치할 수 있음.
* 사용하지 않는 공간이 물리 메모리 차지를 방지.
<img src="image\19.1.png">
* 주소 공간을 물리 메모리에 배치.
<img src="image\19.2.png">
* 주소 공간을 물리 메모리에 배치 시, 세그멘트의 베이스와 바운드 쌍을 이용해 세그멘트들을 독립적으로 물리 메모리에 배치.
* 사용 중인 메모리에만 물리 공간이 할당, 사용되지 않은 많은 대영 주소 공간을 수용 할 수 있음.
* 세그멘트 지원 위한 MMU 하드웨어 구조 예상.
* 개수에 따라 베이스와 바운드 레지스터 집합 필요.
* 베이스 레지스터는 값을 갖음.
* 각 바운드 레지스터는 세그멘트의 크기를 저장.
* 주소의 접근이 잘못된 주소 일 경우, 운영체제는 감지하여 트랩 발생 시킴 -> segment fault
##  19.2 세그멘트 종류의 파악
하드웨어 변환을 위해 세그멘트 레지스터 사용.
하드웨어는 가상 주소가 어느 세그멘트 참조하는지? 세그멘트 안의 오프셋 얼마인지 어떻게 알 수 있지?
* 접근 방법 1.
    * 가상 주소의 최상위 몇 비트를 기준으로 주소 공간을 여러 세그멘트로 나눔
    * VAX/VMS 시스템 사용(추후 책 내용에서 배울 듯.)
    * <img src="image\세그먼트오프셋1.png">
    * 주소 공간을 세그멘트로 나누기 위해 2비트 필요
    * 최상이 2비트가 00이면, 하드웨어는 가상 주소가 코드 세그멘트를 기다림을 알고, 코드 세그멘트의 베이스와 바운드 쌍을 이용하여 정확한 물리 메모리를 재배치.
    * 01이면 하드웨어는 주소가 힙 세그멘테이션 인지해 힙의 베이스와 바운드 사용.
    * <img src="image\세그먼트오프셋2.png">
    * 해당 예시 이미지.
    * 하위 12비트는 세그멘트 내의 오프셋. 하드웨어는 세그멘트 레지스터 파악하는데 2비트 사용하고, 세그멘트 오프셋으로 12비트 사용.
    * 오프셋에 베이스 레지스터 값 더해 최종 물리 주소 계산.
    * 오프셋은 바운드 검사 쉽게 만듬. 오프셋이 바운드보다 작은지 검사.
    * 세그멘트 종류 나타나내는데 최상위 2비트 사용.
    * 주소 공간에는 세 개의 세그멘트(코드, 힙, 스택) 존재해 지정 가능한 세그멘트 하나는 미사용
    * 전체 주소 공간의 1/4 사용 불가.
> 묵시적 접근 방식. 주소가 어떻게 형성되었나 관찰해 세그멘트 결정. 주소가 프로그램 카운터에서 생성 시, 주소는 코드 세그멘트 내에 있으며, 주소가 스택 또는 베이스 포인터 기반 있을 시 주소는 스택 세그멘트 내에 있음.
## 19.3 스택
스택의 경우 다른 세그멘트들과는 반대 방향으로 확장. 다른 방식의 변환 필요.
1. 간단한 하드웨어 추가 필요.
    * 베이스와 바운드 값뿐 아니라 하드웨어 세그멘트가 어느 방향 확장인지 알아야함.
    * 하드웨어는 세그멘트가 반대 방향으로 늘어날 수 있어, 가장 주소에 대한 다른 방식의 변한 필요.
## 19.4 공유 지원
세그멘테이선 기법 발전에 따라, 하드웨어 지원으로 새로운 종류의 효율성을 성취할 수 있음
메모리를 절약하기 위해 주소 공간들 간에 특정 메모리 세그멘트를 공유하는 것 유용.
코드 공유가 일반적임.
* 공유 지원 위해 하드웨어 protection bit의 추가 필요.
* 세그멘트마다 protection bit 추가해  세그멘트 읽고 쓸수 있는지
* 세그멘트 코드 실행 시킬 수 있는지 나타냄.
* 코드 세그멘트 읽기 전용 설정 시 주소 공간의 독립성 유지, 여러 프로세스 주소 공간의 일부 공유.
* 프로세스는 자신 전용 메모리가 있다고 생각하지만, 운영체제가 메모리 영역을 비밀리에 공유 시킴.
## 19.5 소단위 대 단위 세그멘테이션
위의 내용은 소단위 세그멘테이션 지원하는 시스템에 초점이 맞춰짐.
*대단위 세그멘테이션 -> 주소 공간을 비교적 큰 단위 공간으로 분할.
* 초기 주소 공간을 작은 크기의 공간으로 잘게 나누는 것이 허용되었기에 소규모 세그멘테이션으로 불림.
* 수 많은 세그멘트 지원하기 위해 세그멘트 테이블 필요.
* 세그멘트 테이블 이 용시 많은 세그멘트 손쉽게 생성 및 융통성 있게 세그멘트 사용 가능.
## 19.6 운영체제의 지원
* 주소 공간 구성 요소를 별도로 물리 메미로 재배치 하기에 전체 주소 공간이 하나의 베이스 바운드 쌍을 가지는 방식에 비해 물리 메모리를 절약.
* 스택과 힙 사이의 사용하지 않는 공간에 물리 메모리 할당할 필요 없음.
* 문맥 교환시 운영체제는 어떻게 일해야하나?
    * 세그멘트 레지스터의 저장과 복원.
    * 프로세스 가상 주소 공간 가지며, 운영체제 프로세스가 다시 실행하기 전ㅇ 레지스터 올바르게 설정.
* 미사용중인 물리 메모리의 공간 관리.
    * 새로운 주소 생성시 운영체제는 이 공간의 세그멘트를 위한 물리 메모리 영역을 찾아야함.
* 물리 메모리가 빠르게 작은 크기의 빈 공간들로 채워질 떄, 새로이 생겨나는 세그멘트 할당이 힘들며 기존 세그멘트 확장에 도움되지 않음 -> 외부 단편화 문제.
* 문제 해결 = 세그멘트 정리하여 물리 메모리 압축!
    * 압축으로 공간을 확보할수 있지만, 세그멘트 복사는 메모리 부하가 큰 연산, 상당량의 프로세서 시간을 사용하기에 압축 비용은 많이든다.
* 문제 해결 = 빈 공간 리스트 관리 알고리즘
    * 최적 적합
    * 최악 적합
    * 최초 적합
    * 버디 알고리즘
## 19.7 요약
* 세그멘테이션은 메모리 가상화를 효과적으로 실현.
* 단순 동적 재배치 넘어 주소 공간 상의 논리 세그멘트 사이의 큰 공간 낭비 피함으로 주소 공간을 지원
* 산술 연산 쉽고 하드웨어 구현 적합
* 변환 오버헤드 최소
* 코드 공유 장점
* 코드가 별도의 세그멘트 존재 시 코드는 실행 중인 여러 프로그램 사이에 공유
* 세그멘트 크기가 일정하지 않기에 외부 단편화 발생
* 세그멘트는 가변 크기이기에 빈 공간들의 크기 역시 다 달라 메모리 할당 요청을 충족 시키는 것이 어려울수 있음.
* 메모리 압축할 수 있지만 태생적인 문제이기에 회피는 어려움
* 드문드문 사용되는 주소 공간을 지원할만큼 유연하지 못함.
* 주소 공간이 사용되는 모델과 이를 지원하기 위한 세그멘테이션 설계 방법이 정확히 일치하지 않는다면 세그멘테이션을 제대로 동작하지 않음
* 해결책 찾을 준비 됐나?